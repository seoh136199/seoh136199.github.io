<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://seoh136199.github.io/</id><title>Seohyun's DEVlog</title><subtitle>백준 문제 풀이와 프로젝트 개발 일지를 포스팅합니다</subtitle> <updated>2025-09-26T17:15:48+09:00</updated> <author> <name>Seohyun Yang</name> <uri>https://seoh136199.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://seoh136199.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://seoh136199.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 Seohyun Yang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[C++] lvalue와 rvalue</title><link href="https://seoh136199.github.io/posts/cpp-lvalue-rvalue/" rel="alternate" type="text/html" title="[C++] lvalue와 rvalue" /><published>2025-09-25T00:00:00+09:00</published> <updated>2024-09-25T00:00:00+09:00</updated> <id>https://seoh136199.github.io/posts/cpp-lvalue-rvalue/</id> <content src="https://seoh136199.github.io/posts/cpp-lvalue-rvalue/" /> <author> <name>Seohyun Yang</name> </author> <category term="Computer Science" /> <summary> 이 글은 현재 작성 중입니다. • 값 범주의 종류 • 용어 설명 +--------------+ | expression | +--------------+ | +---------+---------+ ↓ ↓ +-----------+ +-----------+ | glvalue | | rvalue | +-----------+ +-----------+... </summary> </entry> <entry><title>[Pancht] 요트 다이스 AI 플레이 통계 및 분석</title><link href="https://seoh136199.github.io/posts/yacht-dice-ai-play-statistics/" rel="alternate" type="text/html" title="[Pancht] 요트 다이스 AI 플레이 통계 및 분석" /><published>2025-01-18T00:00:00+09:00</published> <updated>2025-01-18T00:00:00+09:00</updated> <id>https://seoh136199.github.io/posts/yacht-dice-ai-play-statistics/</id> <content src="https://seoh136199.github.io/posts/yacht-dice-ai-play-statistics/" /> <author> <name>Seohyun Yang</name> </author> <category term="Development Log" /> <summary> • 서론 • 지난번 게시글에서는 요트 다이스 최적 선택 알고리즘을 구현한 방법을 소개하며, 평균 점수 200점대 초반이라는 준수한 성능을 보였다고 언급했었다. 게임 플레이 에이전트를 만들었으니, 통계와 분석을 진행해 보는 것이 당연한 수순이다. 이번에는 평균 점수뿐만 아니라 다양한 데이터를 추출하여 시각화해 보았다. • 점수 분포 살펴보기 • 최종 점수 분포 위 그래프는 천만 회의 시뮬레이션을 통해 얻은 최종 점수 분포를 나타낸다. X축은 최종 점수, Y축은 해당 점수가 나온 횟수이다. 최저점은 64점, 최고점은 333점으로 꽤 넓은 범위를 보이지만, 양쪽 극단 영역의 빈도는 매우 낮다. 따라서 매우 높은 확률로 130점에서 300점 사이의 점수를 받았다는 걸 알 수 있다. ... </summary> </entry> <entry><title>[Pancht] 요트 다이스 최적 선택 알고리즘을 구현한 방법</title><link href="https://seoh136199.github.io/posts/yacht-dice-optimal-selection-algorithm/" rel="alternate" type="text/html" title="[Pancht] 요트 다이스 최적 선택 알고리즘을 구현한 방법" /><published>2024-12-31T00:00:00+09:00</published> <updated>2024-12-31T00:00:00+09:00</updated> <id>https://seoh136199.github.io/posts/yacht-dice-optimal-selection-algorithm/</id> <content src="https://seoh136199.github.io/posts/yacht-dice-optimal-selection-algorithm/" /> <author> <name>Seohyun Yang</name> </author> <category term="Development Log" /> <summary> • 서론 • 왜 하게 되었는가 요트 다이스의 룰을 차용한 Pancht라는 게임에 AI 대전 모드를 넣게 되었다. 이 AI는 숙련된 플레이어의 실력에 준하는, 또는 그 이상의 실력을 갖춰야 고티어 플레이어와 유의미한 대결이 가능할 것이다. 숙련된 플레이어의 의사 결정을 모방해서 로직을 직접 작성하는 방법도 있겠지만 코드가 매우 복잡해질 것으로 예상되었고, 이후 설명할 방식에 비하면 획득할 수 있는 최종 점수의 기댓값이 낮을 것 같았다. 따라서 플레이 종료 시점까지의 미래를 전부 계산하여 항상 최적의 선택을 하는 AI 알고리즘을 짜서 구현하기로 했다. (저티어 플레이어를 위한 실력 조절에 대해서는 추후 포스팅 예정) 요트 다이스 게임을 하며 플레이어가 주사위를 굴린 직후, 마주할 수 있는 경우의 수를... </summary> </entry> <entry><title>[Spready] 착시 연결 기믹을 구현한 방법</title><link href="https://seoh136199.github.io/posts/spready-optical-illusion-gimmick/" rel="alternate" type="text/html" title="[Spready] 착시 연결 기믹을 구현한 방법" /><published>2024-10-23T00:00:00+09:00</published> <updated>2024-10-27T00:00:00+09:00</updated> <id>https://seoh136199.github.io/posts/spready-optical-illusion-gimmick/</id> <content src="https://seoh136199.github.io/posts/spready-optical-illusion-gimmick/" /> <author> <name>Seohyun Yang</name> </author> <category term="Development Log" /> <summary> • Spready 스팀 페이지 • • Spready 플레이스토어 • • Spready Demo 플레이스토어 • 게임 소개 Spready에 대해 간단한 소개부터 하자면, 4개 챕터로 이루어진 색칠하는 3D 퍼즐 게임이다. 각 스테이지에는 캔버스가 배치되어 있다. 플레이어는 크레파스와 지우개를 사용해 모든 캔버스를 색칠하면 된다. 거기에 휘어진 캔버스도 등장한다. 크레파스가 딱딱할 줄 알았겠지만 사실 아니다 2챕터부터는 캔버스를 회전시킬 수 있는 바퀴도 보이기 시작한다. 3챕터부터는 카메라 각도를 잘 맞추면 크레파스나 지우개를 복제할 수 있다. 그럼 4챕터엔 뭐가 나올까? 이 글에서 설명하려고 하는 착시 연결 기믹이다.... </summary> </entry> <entry><title>[백준 4781번] 사탕 가게 [C++]</title><link href="https://seoh136199.github.io/posts/boj-4781/" rel="alternate" type="text/html" title="[백준 4781번] 사탕 가게 [C++]" /><published>2022-08-26T00:00:00+09:00</published> <updated>2022-08-26T00:00:00+09:00</updated> <id>https://seoh136199.github.io/posts/boj-4781/</id> <content src="https://seoh136199.github.io/posts/boj-4781/" /> <author> <name>Seohyun Yang</name> </author> <category term="Baekjoon" /> <summary> 4781번: 사탕 가게 문제 링크: 4781번: 사탕 가게 개요 각 테스트케이스마다 사탕 n개의 칼로리와 가격이 주어졌을 때, m만큼의 돈으로 얻을 수 있는 최대 칼로리를 출력하는 문제이다. 0/1 배낭 문제의 형태를 띠고 있지만 각 사탕을 무제한으로 구매할 수 있고, 가격이 정수가 아니라는 점을 고려해야 한다. 풀이 n과 m 입력받기 int n, m; double tmp; scanf("%d %lf", &amp;amp;n, &amp;amp;tmp); m = (int)(tmp * 100 + 0.5); 이 문제에서 상근이가 가지고 있는 돈의 양 m은 소수점 둘째자리까지 주어지는 실수이다. 그러나 실수로는 dp를 수행하기 어렵기 때문에 100을 곱해 정수로 만들어서 사용했다. int로 강제형변환 하기 ... </summary> </entry> </feed>
