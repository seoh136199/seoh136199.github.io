<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /><meta name="day-prompt" content="days ago" /><meta name="hour-prompt" content="hours ago" /><meta name="minute-prompt" content="minutes ago" /><meta name="justnow-prompt" content="just now" /><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[백준 11438번] LCA 2 [C++]" /><meta property="og:locale" content="en" /><meta name="description" content="11438번: LCA 2" /><meta property="og:description" content="11438번: LCA 2" /><link rel="canonical" href="https://seoh136199.github.io/posts/boj-11438/" /><meta property="og:url" content="https://seoh136199.github.io/posts/boj-11438/" /><meta property="og:site_name" content="Seohyun’s DEVlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-08T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[백준 11438번] LCA 2 [C++]" /><meta name="twitter:site" content="@fried_ctex" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-08T00:00:00+09:00","datePublished":"2022-01-08T00:00:00+09:00","description":"11438번: LCA 2","headline":"[백준 11438번] LCA 2 [C++]","mainEntityOfPage":{"@type":"WebPage","@id":"https://seoh136199.github.io/posts/boj-11438/"},"url":"https://seoh136199.github.io/posts/boj-11438/"}</script><title>[백준 11438번] LCA 2 [C++] | Seohyun's DEVlog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Seohyun's DEVlog"><meta name="application-name" content="Seohyun's DEVlog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" /><link rel="dns-prefetch" href="https://fonts.gstatic.com" /><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials" /><link rel="dns-prefetch" href="https://www.google-analytics.com" /><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous" /><link rel="dns-prefetch" href="https://www.googletagmanager.com" /><link rel="preconnect" href="https://cdn.jsdelivr.net" /><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" /><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/ProfileImage.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Seohyun's DEVlog</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/seoh136199" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/fried_ctex" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['seoh136199','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[백준 11438번] LCA 2 [C++]</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[백준 11438번] LCA 2 [C++]</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Seohyun Yang </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Jan 8, 2022, 12:00 AM +0900" >Jan 8, 2022<i class="unloaded">2022-01-08T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Jan 8, 2022, 12:00 AM +0000" >Jan 8, 2022<i class="unloaded">2022-01-08T00:00:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1534 words">8 min read</span></div></div><div class="post-content"><h1 id="11438번-lca-2-">11438번: LCA 2 <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 25 34'%3E%3C/svg%3E" data-proofer-ignore data-src="https://d2gd6pc034wcta.cloudfront.net/tier/16.svg" width="25" height="34" /></h1><p>문제 링크: <a href="https://www.acmicpc.net/problem/11438" title="bj11438">11438번: LCA 2</a></p><hr /><h2 id="개요"><strong>개요</strong></h2><p>최소 공통 조상(Lowest common ancestor, LCA)는 트리에 어떤 두 정점 u와 v가 있을 때, u 자신이거나 u의 조상인 동시에 v 자신이거나 v의 조상인 노드들 중 가장 깊은 노드이다. LCA 알고리즘의 기본 흐름은 다음과 같다.</p><ol><li>두 정점 중 깊이가 더 깊은 정점에서 출발한다.<li>다른 정점의 깊이와 같아질 때까지 부모 노드로 이동한다.<li>깊이가 같은 두 정점에서 동시에 출발하여 부모 노드로 이동한다.<li>한 노드에서 만났을 때 이동을 종료한다.<li>만난 노드가 LCA이며, 총 이동 횟수가 두 노드 간의 최소 거리이다.</ol><hr /><h2 id="전처리-depth-배열과-parent-배열"><strong>전처리 (depth 배열과 parent 배열)</strong></h2><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">MAX_LOG_N</span><span class="p">];</span> <span class="c1">//parent[n][k] : 노드 n의 2^k번째 부모</span>
<span class="kt">int</span> <span class="n">depth</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</pre></table></code></div></div><p>tree[i]는 노드 i와 연결된 모든 노드의 번호를 저장하는 vector이며, depth[i]은 노드 i의 깊이를 저장한다. 노드 1은 루트 노드이기 때문에 depth[1]은 0이다.<br /> i번째 노드의 1번째 부모가 parent[i]인 일차원 배열을 사용해도 위에서 말한 흐름을 따라가며 LCA를 찾을 수 있다. 그러나 해당 방식은 부모 노드로 타고 올라가는 과정의 시간 복잡도가 O(n)이기 때문에 전체 시간 복잡도가 O(n*m)이 되어 이 문제에서는 시간 초과가 발생하게 된다. 따라서 노드 n의 2^k번째 부모(1번째 부모가 바로 위의 노드)를 parent[n][k]에 저장하는 이차원 배열을 사용했다.</p><h3 id="parentn0와-depth-배열-채우기"><strong>parent[n][0]와 depth 배열 채우기</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">explore</span><span class="p">(</span><span class="kt">int</span> <span class="n">currNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">currNode</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nextNode</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">currNode</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">[</span><span class="n">nextNode</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">currNode</span><span class="p">;</span>
			<span class="n">depth</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">currNode</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">explore</span><span class="p">(</span><span class="n">nextNode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>일반적인 DFS의 형태를 가진 재귀 함수이다. 메인 함수에서 explore(1)을 호출하여 루트 노드인 1에서부터 출발해 자식 노드로 내려가며 각 노드의 depth와 parent[n][0] (노드 n의 첫 번째 부모) 에 값을 넣어준다.</p><h3 id="parent-배열-나머지-채우기"><strong>parent 배열 나머지 채우기</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_LOG_N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>explore() 함수가 실행되면서 parent[n][0]만 채워졌다. 노드 n의 2^k번째 부모를 parent[n][k]에 넣어줘야 한다. 어떤 노드 i의 j번째 조상의 j번째 조상은 i의 2*j번째 조상이고, 이는 곧 parent[i][j + 1]이다. 따라서 parent[i][j + 1]는 parent[parent[i][j]][j]의 형태로 나타낼 수 있다.</p><hr /><h2 id="쿼리-처리하기"><strong>쿼리 처리하기</strong></h2><h3 id="depthu--depthv로-유지"><strong>depth[u] &gt;= depth[v]로 유지</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">};</span>
</pre></table></code></div></div><p>이후 작업을 편하게 하기 위해 u의 깊이가 v의 깊이보다 깊거나 같게 되도록 조건문을 추가했다.</p><h3 id="두-노드의-깊이-맞추기"><strong>두 노드의 깊이 맞추기</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="n">diff</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>두 노드의 깊이 차이를 diff에 저장해놓고, u의 깊이가 v의 깊이와 같아질 때까지 parent[u]를 이용해 u를 부모 노드로 이동시키는 작업이다. j는 밑이 2인 로그 스케일로 변화하는 변수이기 때문에 2진수 변환과 같은 방법을 이용했다. 부모 노드로 한 칸씩 이동하는 방법보다 훨씬 빠르게 두 노드의 깊이를 맞출 수 있다.</p><h3 id="lcs-구하기"><strong>LCS 구하기</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">MAX_LOG_N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
</pre></table></code></div></div><p>두 노드의 깊이가 같아졌으므로 부모 노드가 다른 동안 부모 노드로 한 칸씩 이동해준다. 이동 후 u와 v는 LCS의 바로 자식 노드이기 때문에 마지막으로 한 칸 더 이동 후 출력해준다.</p><hr /><h2 id="전체-코드"><strong>전체 코드</strong></h2><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="c1"> </span><span class="cp">
#pragma warning(disable:4996)
#pragma warning(disable:6031)
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define MAX_N 100000
#define MAX_LOG_N 18
</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">MAX_LOG_N</span><span class="p">];</span> <span class="c1">//parent[n][k] : n번째 노드의 2^k번째 부모</span>
<span class="kt">int</span> <span class="n">depth</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">explore</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

	<span class="c1">//트리 입력받기</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="n">tree</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//depth, parent 배열 초기화</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_LOG_N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">depth</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">//parent[n][0]과 depth 배열 채우기</span>
	<span class="n">explore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="c1">//parent 배열 채우기</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_LOG_N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//쿼리 입력받기</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

		<span class="c1">//depth[u] &gt;= depth[v]로 유지</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">};</span>
		<span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
		
		<span class="c1">//두 노드의 깊이 맞추기</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="n">diff</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">MAX_LOG_N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
					<span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">explore</span><span class="p">(</span><span class="kt">int</span> <span class="n">currNode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">currNode</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nextNode</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">currNode</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span><span class="p">[</span><span class="n">nextNode</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">currNode</span><span class="p">;</span>
			<span class="n">depth</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">currNode</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">explore</span><span class="p">(</span><span class="n">nextNode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/baekjoon/'>Baekjoon</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a> <a href="/tags/baekjoon/" class="post-tag no-text-decoration" >Baekjoon</a> <a href="/tags/data-structure/" class="post-tag no-text-decoration" >Data structure</a> <a href="/tags/tree/" class="post-tag no-text-decoration" >Tree</a> <a href="/tags/lowest-common-ancestor/" class="post-tag no-text-decoration" >Lowest common ancestor</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[백준 11438번] LCA 2 [C++] - Seohyun's DEVlog&url=https://seoh136199.github.io/posts/boj-11438/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[백준 11438번] LCA 2 [C++] - Seohyun's DEVlog&u=https://seoh136199.github.io/posts/boj-11438/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[백준 11438번] LCA 2 [C++] - Seohyun's DEVlog&url=https://seoh136199.github.io/posts/boj-11438/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/yacht-dice-ai-play-statistics/">[Pancht] 요트 다이스 AI 플레이 통계 및 분석</a><li><a href="/posts/yacht-dice-optimal-selection-algorithm/">[Pancht] 요트 다이스 최적 선택 알고리즘을 구현한 방법</a><li><a href="/posts/spready-optical-illusion-gimmick/">[Spready] 착시 연결 기믹을 구현한 방법</a><li><a href="/posts/cpp-lvalue-rvalue/">[C++] lvalue와 rvalue</a><li><a href="/posts/boj-4781/">[백준 4781번] 사탕 가게 [C++]</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/baekjoon/">Baekjoon</a> <a class="post-tag" href="/tags/data-structure/">Data structure</a> <a class="post-tag" href="/tags/graph/">Graph</a> <a class="post-tag" href="/tags/segment-tree/">Segment tree</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/dynamic-programming/">Dynamic Programming</a> <a class="post-tag" href="/tags/minimum-spanning-tree/">Minimum Spanning Tree</a> <a class="post-tag" href="/tags/pancht/">Pancht</a> <a class="post-tag" href="/tags/sort/">Sort</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/boj-2696/"><div class="card-body"> <span class="timeago small" >Feb 27, 2022<i class="unloaded">2022-02-27T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준 2696번] 중앙값 구하기 [C++]</h3><div class="text-muted small"><p> 2696번: 중앙값 구하기 문제 링크: 2696번: 중앙값 구하기 개요 문제가 시킨 일인 수열이 주어지면 홀수 번째 수를 읽을 때마다 중앙값을 출력하는 작업만 착실하게 수행하면 되는 문제이다. 하지만 매번 수열을 정렬하고 중간 인덱스 값을 출력하는 방식으로는 시간초과를 피할 수 없다. 따라서 우선순위 큐를 두 개 이용해서 풀이할 것이다. ma...</p></div></div></a></div><div class="card"> <a href="/posts/boj-1395/"><div class="card-body"> <span class="timeago small" >Aug 11, 2022<i class="unloaded">2022-08-11T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준 1395번] 스위치 [C++]</h3><div class="text-muted small"><p> 1395번: 스위치 문제 링크: 1395번: 스위치 개요 세그먼트 트리를 이용해 쿼리를 수행하고 부분합을 출력하는 문제이다. 그러나 원소의 개수와 쿼리의 개수가 최대 100,000으로, 평범한 세그먼트 트리로 풀이하면 시간 초과를 맞이하는 미래가 찾아온다. 이 문제는 ‘느리게 갱신되는 세그먼트 트리’ 알고리즘을 이용할 것이다. 평범한 세그...</p></div></div></a></div><div class="card"> <a href="/posts/boj-1774%EB%B2%88/"><div class="card-body"> <span class="timeago small" >Jan 18, 2022<i class="unloaded">2022-01-18T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준 1774번] 우주신과의 교감 [C++]</h3><div class="text-muted small"><p> 1774번: 우주신과의 교감 문제 링크: 1774번: 우주신과의 교감 개요 최소 스패닝 트리(Minimum Spanning Tree, MST)는 주어진 그래프의 모든 정점을 연결하는 부분 그래프 중에서 사용된 간선들의 가중치 합이 최소인 트리이다. 다시 말하면 n개 노드가 있을 때, n-1개 간선만을 이용해 가장 적은 가중치로 모든 노드를 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/oop-unity-basic/" class="btn btn-outline-primary" prompt="Older"><p>[Unity] 객체 지향과 유니티 기초 개념</p></a> <a href="/posts/boj-1774%EB%B2%88/" class="btn btn-outline-primary" prompt="Newer"><p>[백준 1774번] 우주신과의 교감 [C++]</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/fried_ctex">Seohyun Yang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/baekjoon/">Baekjoon</a> <a class="post-tag" href="/tags/data-structure/">Data structure</a> <a class="post-tag" href="/tags/graph/">Graph</a> <a class="post-tag" href="/tags/segment-tree/">Segment tree</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/dynamic-programming/">Dynamic Programming</a> <a class="post-tag" href="/tags/minimum-spanning-tree/">Minimum Spanning Tree</a> <a class="post-tag" href="/tags/pancht/">Pancht</a> <a class="post-tag" href="/tags/sort/">Sort</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://seoh136199.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VTZLYLE721"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VTZLYLE721'); }); </script>
