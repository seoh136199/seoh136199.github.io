<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /><meta name="day-prompt" content="days ago" /><meta name="hour-prompt" content="hours ago" /><meta name="minute-prompt" content="minutes ago" /><meta name="justnow-prompt" content="just now" /><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[백준 1774번] 우주신과의 교감 [C++]" /><meta property="og:locale" content="en" /><meta name="description" content="1774번: 우주신과의 교감" /><meta property="og:description" content="1774번: 우주신과의 교감" /><link rel="canonical" href="https://seoh136199.github.io/posts/boj-1774%EB%B2%88/" /><meta property="og:url" content="https://seoh136199.github.io/posts/boj-1774%EB%B2%88/" /><meta property="og:site_name" content="Seohyun’s DEVlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-18T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[백준 1774번] 우주신과의 교감 [C++]" /><meta name="twitter:site" content="@fried_ctex" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-18T00:00:00+09:00","datePublished":"2022-01-18T00:00:00+09:00","description":"1774번: 우주신과의 교감","headline":"[백준 1774번] 우주신과의 교감 [C++]","mainEntityOfPage":{"@type":"WebPage","@id":"https://seoh136199.github.io/posts/boj-1774%EB%B2%88/"},"url":"https://seoh136199.github.io/posts/boj-1774%EB%B2%88/"}</script><title>[백준 1774번] 우주신과의 교감 [C++] | Seohyun's DEVlog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Seohyun's DEVlog"><meta name="application-name" content="Seohyun's DEVlog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" /><link rel="dns-prefetch" href="https://fonts.gstatic.com" /><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials" /><link rel="dns-prefetch" href="https://www.google-analytics.com" /><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous" /><link rel="dns-prefetch" href="https://www.googletagmanager.com" /><link rel="preconnect" href="https://cdn.jsdelivr.net" /><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" /><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/ProfileImage.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Seohyun's DEVlog</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/seoh136199" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/fried_ctex" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['seoh136199','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[백준 1774번] 우주신과의 교감 [C++]</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[백준 1774번] 우주신과의 교감 [C++]</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Seohyun Yang </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 18, 2022, 12:00 AM +0900" >Jan 18, 2022<i class="unloaded">2022-01-18T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 18, 2022, 12:00 AM +0000" >Jan 18, 2022<i class="unloaded">2022-01-18T00:00:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1946 words">10 min read</span></div></div><div class="post-content"><h1 id="1774번-우주신과의-교감-">1774번: 우주신과의 교감 <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 25 34'%3E%3C/svg%3E" data-proofer-ignore data-src="https://d2gd6pc034wcta.cloudfront.net/tier/13.svg" width="25" height="34" /></h1><p>문제 링크: <a href="https://www.acmicpc.net/problem/1774" title="bj1774">1774번: 우주신과의 교감</a></p><hr /><h2 id="개요"><strong>개요</strong></h2><p><strong>최소 스패닝 트리</strong>(Minimum Spanning Tree, MST)는 주어진 그래프의 모든 정점을 연결하는 부분 그래프 중에서 사용된 간선들의 가중치 합이 최소인 트리이다. 다시 말하면 n개 노드가 있을 때, n-1개 간선만을 이용해 가장 적은 가중치로 모든 노드를 연결하는 것이다.<br /> 이 문제에서 황선자씨가 모든 우주신들과 교감할 수 있도록 정신적 통로들을 만들어줘야 하므로, 최소 스패닝 트리를 구하는 알고리즘을 그대로 적용하여 풀이할 수 있다.<br /> 최소 스패닝 트리를 구하는 알고리즘에는 <strong>크루스칼 알고리즘</strong>과 <strong>프림 알고리즘</strong>이 있다. 노드에 비해 간선의 개수가 적은 경우엔 크루스칼 알고리즘이, 간선의 개수가 많은 경우에는 프림 알고리즘이 더 효율적이다. 이 문제는 사실상 모든 정점이 다른 정점과 연결된 간선이 있는 것과 마찬가지이기 때문에 프림 알고리즘이 효율적일 수 있지만, 나는 효율성과 별개로 크루스칼 알고리즘을 이용해 풀이했다.</p><hr /><h2 id="크루스칼-알고리즘"><strong>크루스칼 알고리즘</strong></h2><p>크루스칼 알고리즘의 전체 흐름은 다음과 같다.</p><ol><li>간선들을 가중치에 대해 오름차순으로 정렬한다.<li>간선들을 순서대로 탐색하며 해당 간선의 두 노드가 현재 연결되어 있지 않다면 간선을 선택하고 아니면 건너뛴다.<li>모든 간선에 대해 해당 작업을 반복하여 총 n-1개의 간선이 선택된 상태에서 마무리한다.</ol><p>여기서 두 노드가 연결되어 있는지 확인하기 위해 Union-Find 알고리즘을 이용했다.</p><hr /><h2 id="풀이"><strong>풀이</strong></h2><h3 id="전처리"><strong>전처리</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">//n개 노드 좌표 입력</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">posX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">posY</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//입력받은 좌표로 nC2개 간선 생성</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edges</span><span class="p">[</span><span class="n">edgesCnt</span><span class="p">].</span><span class="n">node1</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">edgesCnt</span><span class="p">].</span><span class="n">node2</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">edges</span><span class="p">[</span><span class="n">edgesCnt</span><span class="p">].</span><span class="n">dist</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">posX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">posX</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">posY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">posY</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">edgesCnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//dist 오름차순으로 간선 정렬</span>
<span class="n">qsort</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edgesCnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">compare</span><span class="p">);</span>
</pre></table></code></div></div><p>배열 posX와 배열 posY에 n개 노드의 x좌표와 y좌표를 각각 입력받은 후, nC2개 간선(노드 개수가 n개이므로 그 중 2개를 선택하는 경우의 수는 nC2)을 생성해 구조체 배열 edges에 저장한 후, 가중치(이 문제에서는 평면상에서의 거리)에 대해 오름차순 정렬한다.</p><h3 id="union-find"><strong>Union-Find</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">//조상 노드 찾기</span>
<span class="kt">int</span> <span class="nf">getRoot</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//두 노드 union하기</span>
<span class="kt">void</span> <span class="nf">unionNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">root1</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">root2</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">&lt;</span> <span class="n">root2</span><span class="p">)</span> <span class="n">parent</span><span class="p">[</span><span class="n">root2</span><span class="p">]</span> <span class="o">=</span> <span class="n">root1</span><span class="p">;</span>
	<span class="k">else</span> <span class="n">parent</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root2</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>두 노드가 연결되어 있는지를 알기 위해 <strong>두 노드의 조상 노드가 같은지</strong>를 확인한다는 것이 크루스칼 알고리즘에서 Union-Find를 이용하는 기본 아이디어이다.<br /> 연결된 노드 중 번호가 작은 노드를 부모 노드로 가정하여 Union-Find를 진행한다. parent[n]은 n번 노드의 부모 노드 중 하나가 들어있으며, 그것이 <strong>항상 조상 노드라는 보장은 없다</strong>.<br /> getRoot 함수는 parent 배열을 이용해 조상 노드를 반환한다. getRoot(parent, n)을 호출하면 n번 노드에서 조상 노드까지 가기 위해 재귀를 타고 거치는 모든 노드들(k1, k2 …)에 대해 parent[k1], parent[k2]…가 <strong>해당 노드의 조상 노드로 업데이트된다</strong>. 따라서 다음번에 그 노드의 조상 노드를 찾아야 할 때 시간을 단축할 수 있다.<br /> unionNode에서는 두 노드를 연결시킨다(조상 노드를 같게 한다). 두 노드의 조상 노드 root1과 root2를 각각 구하고, 두 조상 중 번호가 큰 노드를 v, 번호가 작은 노드를 u라고 하겠다. 원래 u의 자식이었던 노드들에게는 아무 변화가 없다. 그러나 v의 자식이었던 노드들은 다음번에 getRoot의 인자로 넣어 호출하면 v까지 타고 올라간 후, <strong>parent[v]에 할당된 u가 해당 노드의 조상 노드로 업데이트된다</strong>.</p><h3 id="최소-스패닝-트리-만들기"><strong>최소 스패닝 트리 만들기</strong></h3><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">//이미 연결된 것으로 주어지는 노드 union</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="n">unionNode</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//크루스칼 알고리즘으로 최소 스패닝 트리 만들기</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edgesCnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node2</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">sumDist</span> <span class="o">+=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dist</span><span class="p">);</span>

		<span class="n">unionNode</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node1</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이 문제에서는 이미 m개 간선으로 노드들이 연결되어있으므로 해당 노드들에 대해 unionNode를 진행해준다.<br /> 그 후 가중치에 대해 오름차순으로 정렬된 간선들을 탐색한다. 두 노드의 조상 노드가 같은 경우 이미 연결된 노드들이므로 건너뛰고, 조상 노드가 다른 경우에만 unionNode를 진행하며 우리가 구해야 하는 가중치 총합에 해당 간선 가충지를 누적하면 완료이다.</p><hr /><h2 id="전체-코드"><strong>전체 코드</strong></h2><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#pragma warning(disable:4996)
#pragma warning(disable:6031)
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define MAX_N 1000
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">edge</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">dist</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Edge</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">getRoot</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">unionNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">double</span> <span class="n">sumDist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">posX</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">posY</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">edgesCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Edge</span> <span class="n">edges</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">*</span> <span class="n">MAX_N</span><span class="p">];</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="c1">//n개 노드 좌표 입력</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">posX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">posY</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//입력받은 좌표로 nC2개 간선 생성</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">edges</span><span class="p">[</span><span class="n">edgesCnt</span><span class="p">].</span><span class="n">node1</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">edgesCnt</span><span class="p">].</span><span class="n">node2</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">edges</span><span class="p">[</span><span class="n">edgesCnt</span><span class="p">].</span><span class="n">dist</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">posX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">posX</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">posY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">posY</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">edgesCnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//dist 오름차순으로 간선 정렬</span>
	<span class="n">qsort</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edgesCnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">compare</span><span class="p">);</span>

	<span class="c1">//이미 연결된 것으로 주어지는 노드 union</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
		<span class="n">unionNode</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//크루스칼 알고리즘으로 최소 스패닝 트리 만들기</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edgesCnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node2</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">sumDist</span> <span class="o">+=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dist</span><span class="p">);</span>

			<span class="n">unionNode</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node1</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"%.2lf"</span><span class="p">,</span> <span class="n">sumDist</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//qsort를 위한 비교 함수</span>
<span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">Edge</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">Edge</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dist</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//조상 노드 찾기</span>
<span class="kt">int</span> <span class="nf">getRoot</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//두 노드 union하기</span>
<span class="kt">void</span> <span class="nf">unionNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node2</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">root1</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">root2</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">&lt;</span> <span class="n">root2</span><span class="p">)</span> <span class="n">parent</span><span class="p">[</span><span class="n">root2</span><span class="p">]</span> <span class="o">=</span> <span class="n">root1</span><span class="p">;</span>
	<span class="k">else</span> <span class="n">parent</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root2</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/baekjoon/'>Baekjoon</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a> <a href="/tags/baekjoon/" class="post-tag no-text-decoration" >Baekjoon</a> <a href="/tags/data-structure/" class="post-tag no-text-decoration" >Data structure</a> <a href="/tags/graph/" class="post-tag no-text-decoration" >Graph</a> <a href="/tags/minimum-spanning-tree/" class="post-tag no-text-decoration" >Minimum Spanning Tree</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[백준 1774번] 우주신과의 교감 [C++] - Seohyun's DEVlog&url=https://seoh136199.github.io/posts/boj-1774%EB%B2%88/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[백준 1774번] 우주신과의 교감 [C++] - Seohyun's DEVlog&u=https://seoh136199.github.io/posts/boj-1774%EB%B2%88/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[백준 1774번] 우주신과의 교감 [C++] - Seohyun's DEVlog&url=https://seoh136199.github.io/posts/boj-1774%EB%B2%88/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/yacht-dice-ai-play-statistics/">[Pancht] 요트 다이스 AI 플레이 통계 및 분석</a><li><a href="/posts/yacht-dice-optimal-selection-algorithm/">[Pancht] 요트 다이스 최적 선택 알고리즘을 구현한 방법</a><li><a href="/posts/spready-optical-illusion-gimmick/">[Spready] 착시 연결 기믹을 구현한 방법</a><li><a href="/posts/cpp-lvalue-rvalue/">[C++] lvalue와 rvalue</a><li><a href="/posts/boj-4781/">[백준 4781번] 사탕 가게 [C++]</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/baekjoon/">Baekjoon</a> <a class="post-tag" href="/tags/data-structure/">Data structure</a> <a class="post-tag" href="/tags/graph/">Graph</a> <a class="post-tag" href="/tags/segment-tree/">Segment tree</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/dynamic-programming/">Dynamic Programming</a> <a class="post-tag" href="/tags/minimum-spanning-tree/">Minimum Spanning Tree</a> <a class="post-tag" href="/tags/pancht/">Pancht</a> <a class="post-tag" href="/tags/sort/">Sort</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/boj-14621/"><div class="card-body"> <span class="timeago small" >Feb 19, 2022<i class="unloaded">2022-02-19T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준 14621번] 나만 안되는 연애 [C++]</h3><div class="text-muted small"><p> 14621번: 나만 안되는 연애 문제 링크: 14621번: 나만 안되는 연애 개요 주어진 그래프에서 노드들을 연결하는 최단 거리 트리의 총 거리를 구하는 문제이다. 최소 스패닝 트리 알고리즘 중 크루스칼 알고리즘을 이용해 풀이하겠다. 최소 스패닝 트리에 대해 [알고리즘] 최소 신장 트리(MST, Minimum Spanning Tree)란 포스...</p></div></div></a></div><div class="card"> <a href="/posts/boj-2696/"><div class="card-body"> <span class="timeago small" >Feb 27, 2022<i class="unloaded">2022-02-27T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준 2696번] 중앙값 구하기 [C++]</h3><div class="text-muted small"><p> 2696번: 중앙값 구하기 문제 링크: 2696번: 중앙값 구하기 개요 문제가 시킨 일인 수열이 주어지면 홀수 번째 수를 읽을 때마다 중앙값을 출력하는 작업만 착실하게 수행하면 되는 문제이다. 하지만 매번 수열을 정렬하고 중간 인덱스 값을 출력하는 방식으로는 시간초과를 피할 수 없다. 따라서 우선순위 큐를 두 개 이용해서 풀이할 것이다. ma...</p></div></div></a></div><div class="card"> <a href="/posts/boj-1395/"><div class="card-body"> <span class="timeago small" >Aug 11, 2022<i class="unloaded">2022-08-11T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준 1395번] 스위치 [C++]</h3><div class="text-muted small"><p> 1395번: 스위치 문제 링크: 1395번: 스위치 개요 세그먼트 트리를 이용해 쿼리를 수행하고 부분합을 출력하는 문제이다. 그러나 원소의 개수와 쿼리의 개수가 최대 100,000으로, 평범한 세그먼트 트리로 풀이하면 시간 초과를 맞이하는 미래가 찾아온다. 이 문제는 ‘느리게 갱신되는 세그먼트 트리’ 알고리즘을 이용할 것이다. 평범한 세그...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/boj-11438/" class="btn btn-outline-primary" prompt="Older"><p>[백준 11438번] LCA 2 [C++]</p></a> <a href="/posts/boj-4342/" class="btn btn-outline-primary" prompt="Newer"><p>[백준 4342번] 유클리드 게임 [C++]</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/fried_ctex">Seohyun Yang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/baekjoon/">Baekjoon</a> <a class="post-tag" href="/tags/data-structure/">Data structure</a> <a class="post-tag" href="/tags/graph/">Graph</a> <a class="post-tag" href="/tags/segment-tree/">Segment tree</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/dynamic-programming/">Dynamic Programming</a> <a class="post-tag" href="/tags/minimum-spanning-tree/">Minimum Spanning Tree</a> <a class="post-tag" href="/tags/pancht/">Pancht</a> <a class="post-tag" href="/tags/sort/">Sort</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://seoh136199.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-VTZLYLE721"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-VTZLYLE721'); }); </script>
