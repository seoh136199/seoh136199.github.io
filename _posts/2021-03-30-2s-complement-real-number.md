---
title:  "[CS] 2의 보수와 컴퓨터의 실수 표현"

categories:
  - Computer Science

toc: true
toc_sticky: true
 
date: 2021-03-30
last_modified_at: 2021-03-30
---

# **2의 보수**


## **부호 절댓값 방법**

최상위 비트를 부호 비트로 사용한다. 최상위 비트가 0이면 양수, 1이면 음수이다.

예) 0011₂ = 3₁₀ , 1011₂ = -3₁₀

이 방법을 사용하면 계산에 문제가 발생한다.

예) 0001₂(1₁₀) + 1001₂(-1₁₀) = 1010₂(-2₁₀) (1 + (-1)의 결과로 0이 나와야 하는데 -2가 나오게 된다)


## **1의 보수 방법**

계산할 이진수보다 1비트가 더 크고 모든 자릿수가 1인 수에서 원래 수를 빼서 구할 수 있다.

각 자리수의 0과 1을 서로 뒤바꾼 것과 같다.

예) 1101₂ = -2₁₀ , 1000 = -7₁₀

덧뻴셈이 가능하다. 단 자리올림이 발생하면 최하위 비트에 1을 더해야 한다.

예1) 1101₂(-2₁₀) + 1100₂(-3₁₀) = 1001₂ + 0001₂ = 1010₂(-5₁₀)

예2) 0001₂(1₁₀) + 1110₂(-1₁₀) = 1111(-0₁₀)

그러나 부호 절댓값 방법과 마찬가지로 0을 표현하는 방법이 2가지이다.

## **2의 보수 방법**

계산할 이진수보다 1비트가 더 크고 최상위비트만 1인 수에서 원래 수를 빼서 구할 수 있다.

또한 1의 보수에서 1을 더한 값과도 같다.

예) 1110₂ = -2₁₀ , 1001 = -7₁₀

기존 방법들과는 다르게 0을 표현하는 방법이 1가지 뿐이며 자리올림 문제가 해결되었다.

양수로 표현할 수 있는 수의 최댓값보다 1만큼 큰 수를 절댓값으로 가지는 음수까지 표현할 수 있다.

<br>

---

# **컴퓨터의 실수 표현**


컴퓨터에서 실수는 아래와 같이 가수, 밑수, 지수의 3개 부분으로 구성되어있다.

$$
m×r^e⠀( m : 가수⠀r : 밑수⠀e : 지수 )
$$

지수는 바이어스 된 표현법인데, 바이어스라는 고정된 값을 더해서 구할 수 있다.

컴퓨터는 이진법을 사용하므로 밑수는 2₁₀로 고정되어있다.

가수를 표현할 때 소수점 아래 0은 모두 생략하며, 첫 번째 1도 생략한다.

따라서 정수 부분은 1로 고정시키고 소수점 아래 숫자들만을 가수 부분에 저장한다.

이와 같은 지수 형식을 이용한 표현에는 단일 정밀도 형식과 이중 정밀도 형식이 있다.

## **단일 정밀도 형식**

전체 : 32비트
부호비트  : 1비트
지수 부분 : 8비트
가수 부분 : 23비트

바이어스 : 127
지수 표현 범위 : -127 ~ 128

## **이중 정밀도 형식**

전체 : 64비트
부호비트  : 1비트
지수 부분 : 11비트
가수 부분 : 52비트

바이어스 : 1023
지수 표현 범위 : -1023 ~ 1024

<br>

---

# **실수의 오차**

어떤 수를 십진 분수로 나타냈을 때 분모에 2 외의 인수가 있다면 그 수는 무한이진소수점수가 된다.

그러나 가수 부분 저장 공간은 유한하기 때문에 특정 자릿수에서 반올림이 일어나게 되며, 많은 숫자들은 정확한 값이 아닌 근사치로 저장되기 때문에 오차가 발생한다.

예를 들어, 컴퓨터가 0.1 * 0.1을 계산할 때 0.1은 이진수로 바꾸면 무한이진소수점수가 되므로 정확안 값이 아닌 근사치로 연산이 이루어지는데 그 결과는 0.01과 가장 근접한 이진소수점수가 아니기 때문에 아래와 같은 코드를 실행시키면 FALSE라는 값이 출력되는 것을 볼 수 있다.

```c
#include <stdio.h>

int main()
{
    double num = 0.1;
    if (num * num == 0.01) printf("TRUE");
    else printf("FALSE");

    return 0;
}
```

```text
FALSE
```