[ { "title": "[C++] lvalue와 rvalue", "url": "/posts/cpp-lvalue-rvalue/", "categories": "Computer Science", "tags": "C++", "date": "2025-09-25 00:00:00 +0900", "snippet": "이 글은 현재 작성 중입니다.• 값 범주의 종류 •용어 설명 +--------------+ | expression | +--------------+ | +---------+---------+ ↓ ↓ +-----------+ +-----------+ | glvalue | | rvalue | +-----------+ +-----------+ | | +---------+------+ +------+---------+ ↓ ↓ ↓ ↓ +-----------+ +-----------+ +-----------+ | lvalue | | xvalue | | prvalue | +-----------+ +-----------+ +-----------+아래는 MS 공식 문서에 작성된 값 범주에 대한 C++17에서의 정의이다. glvalue: 평가에서 개체, 비트 필드 또는 함수의 ID를 결정하는 식 prvalue: 계산에서 개체 또는 비트 필드를 초기화하거나 표시되는 컨텍스트에 지정된 대로 연산자의 피연산자 값을 계산하는 식 xvalue: 리소스를 재사용할 수 있는 개체 또는 비트 필드를 나타내는 glvalue lvalue: xvalue가 아닌 glvalue rvalue: prvalue 또는 xvalue난해하다. 우리가 일반적으로 자주 사용하는 용어인 lvalue와 rvalue에 대한 직접적인 정의는 없고, glvalue, prvalue, xvalue를 이용해 정의되어 있음을 볼 수 있다.조금 더 풀어서 설명해보자면 아래와 같다. glvalue: 주소값을 갖는 식. 일반적으로 생각하는 lvalue와 유사하나, xvalue를 포함하는 개념이다. 일반적인 변수, 배열 원소, 함수 이름, 문자열 리터럴 등이 이에 속한다. prvalue: 주소값을 갖지 않고, 값 자체를 주는 식. 일반적으로 생각하는 rvalue와 유사하나, xvalue를 포함하지 않는 개념이다. 기본 타입의 리터럴 등이 이에 속한다. xvalue: glvalue 중 곧 소멸하여 자원을 재사용할 수 있는 식. std::move()의 결과 등이 이에 속한다.주의사항값 범주에 대해 공부할 때 주의해야 할 점은, 이는 표현식에 대한 개념이라는 것이다. 문맥과 함께 작성된 표현식은 항상 ‘타입’과 ‘값 범주’를 함께 갖는다. 즉, 어떤 표현식의 값 범주를 판단할 때 타입과 혼동하면 안 된다. 함수 이름이 glvalue에 속한다고 작성했으나, 이는 함수 이름이 함수 그 자체를 가리키는 glvalue라는 의미이며, 함수의 호출식과는 구분해야 한다. 함수의 호출식은 그 함수의 반환값에 따라 값 범주가 결정된다.설명만으로는 감이 잘 오지 않으므로, 예시 코드를 보며 자세히 확인해보겠다.• lvalue의 예시 •이름 붙은 변수, 대입식#include &amp;lt;iostream&amp;gt;using namespace std;int main() { int a = 10, b = 20; cout &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &#39;\\n&#39;; //0000007784EFFB34 (a = b) = 99; cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#39;\\n&#39;; //99 cout &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; &amp;amp;(a = 1) &amp;lt;&amp;lt; &#39;\\n&#39;; //0000007784EFFB34 0000007784EFFB34} a는 lvalue로, 주소 연산자(&amp;amp;)를 사용해 주소값을 얻을 수 있다. 대입식 (a = b)은 다시 a를 가리키는 lvalue이다. 그 자체에 값을 할당할 수 있다. 대입식 (a = b)은 lvalue이므로 a와 마찬가지로 주소 연산자(&amp;amp;)를 사용해 주소값을 얻을 수 있다. 또한 그 주소값은 a와 동일하다.배열 원소, 포인터 역참조#include &amp;lt;iostream&amp;gt;using namespace std;int main() { int arr[3] = { 1,2,3 }; int* p = arr; cout &amp;lt;&amp;lt; &amp;amp;arr[0] &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; &amp;amp;arr[1] &amp;lt;&amp;lt; &#39;\\n&#39;; //000000464A4FF9D8 000000464A4FF9DC cout &amp;lt;&amp;lt; &amp;amp;(*p) &amp;lt;&amp;lt; &#39;\\n&#39;; //000000464A4FF9D8} 배열 arr의 각 원소(arr[0], arr[1] 등)는 lvalue로, 주소 연산자(&amp;amp;)를 사용해 주소값을 얻을 수 있다. 포인터 역참조 *p 또한 lvalue로, 다시 주소 연산자(&amp;amp;)를 붙여 주소값을 얻을 수 있다.함수 이름, 함수가 lvalue 참조를 반환#include &amp;lt;iostream&amp;gt;using namespace std;int&amp;amp; first(int* a) { return a[0]; }int main() { auto *pf = &amp;amp;first; int a[2] = { 7,8 }; first(a) = 42; pf(a) = 100; cout &amp;lt;&amp;lt; a[0] &amp;lt;&amp;lt; &#39;\\n&#39;; //100 cout &amp;lt;&amp;lt; &amp;amp;first(a) &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; &amp;amp;a[0] &amp;lt;&amp;lt; &#39;\\n&#39;; //000000DA922FF688 000000DA922FF688} 함수 이름 first는 함수 타입의 lvalue로, 주소 연산자(&amp;amp;)를 사용해 주소값을 얻을 수 있다. 함수 first()의 반환 타입이 lvalue 참조인 int&amp;amp;이므로, 함수 호출식 first(a)은 lvalue이며 그 자체에 값을 할당할 수 있다. 함수 포인터 pf를 통해 호출해도 동일하게 lvalue 참조를 반환하므로 pf(a) = 100; 또한 유효하다. 함수 first()의 호출식이 lvalue이므로 주소 연산자(&amp;amp;)를 사용할 수 있다. &amp;amp;first(a)는 a[0]의 주소와 동일하다.중제목중제목코드코드 설명설명 • rvalue •• xvalue •" }, { "title": "[Pancht] 요트 다이스 AI 플레이 통계 및 분석", "url": "/posts/yacht-dice-ai-play-statistics/", "categories": "Development Log", "tags": "Pancht", "date": "2025-01-18 00:00:00 +0900", "snippet": "• 서론 •지난번 게시글에서는 요트 다이스 최적 선택 알고리즘을 구현한 방법을 소개하며, 평균 점수 200점대 초반이라는 준수한 성능을 보였다고 언급했었다. 게임 플레이 에이전트를 만들었으니, 통계와 분석을 진행해 보는 것이 당연한 수순이다. 이번에는 평균 점수뿐만 아니라 다양한 데이터를 추출하여 시각화해 보았다.• 점수 분포 살펴보기 •최종 점수 분포 위 그래프는 천만 회의 시뮬레이션을 통해 얻은 최종 점수 분포를 나타낸다. X축은 최종 점수, Y축은 해당 점수가 나온 횟수이다.최저점은 64점, 최고점은 333점으로 꽤 넓은 범위를 보이지만, 양쪽 극단 영역의 빈도는 매우 낮다. 따라서 매우 높은 확률로 130점에서 300점 사이의 점수를 받았다는 걸 알 수 있다.요트 다이스에는 조건 만족 여부에 따라 점수를 얻거나 일정한 고정 점수를 획득하는 카테고리가 많아 정규 분포를 따르지 않으리란 것은 예상했지만 봉우리가 8개나 되는 올록볼록한 그래프의 형태는 예상치 못했다. 이러한 분포가 나타난 원인은 아래에서 자세히 살펴보겠다.Aces~Sixes의 합 분포 상단부 카테고리(Aces~Sixes)의 점수 합만 분리해서 그린 그래프이다. 이 부분에는 고정 점수나 특정 조건으로 점수를 얻는 카테고리가 없기 때문에, 평균 근처에 집중된 단봉형 분포가 나타났다.Choice~Yacht의 합 분포 하단부(Choice~Yacht) 카테고리의 점수 합을 분리해서 그래프를 그려보니, 이 하단부가 올록볼록한 최종 점수 그래프 형태를 만들게 된 주된 원인임을 알게 되었다. 다만 이 그래프에는 봉우리가 6개만 보이는데, 최종 점수 분포에는 봉우리가 8개 나타난 이유를 아래에서 알아보자.• 점수 분포 그래프 분석 •용의자 1: 보너스 점수첫 번째로, 상단부 점수가 63점 이상일 때 추가로 부여되는 보너스 점수 35점이 그래프 형태에 큰 영향을 줄 것으로 예상했다. 위 그래프는 최종 점수를 계산할 때, 보너스를 더해주지 않은 버전이다. 보너스가 포함된 기존 그래프보다 봉우리가 뭉툭해진 모습이 관찰된다. 그 이유를 알기 위해 보너스를 획득에 성공한 경우와 실패한 경우를 분리해서 그래프를 그려보았다. 각 그래프에는 봉우리가 6개씩 나타나며, 두 그래프가 합쳐지면서 최종적으로 8개의 봉우리가 생겼다는 사실을 알 수 있다. 더 명확히 하기 위해 두 그래프를 누적해서 그려보았다. 위쪽 그래프는 보너스를 포함한 버전으로, 최종 점수 그래프와 동일한 모습을 볼 수 있다. 아래쪽 그래프는 보너스를 제외한 버전으로, 보너스를 포함하지 않은 최종 점수 그래프와 동일한 모습을 볼 수 있다.보너스를 포함한 버전에서는, ‘보너스 성공 그래프’와 ‘보너스 실패 그래프’가 서로의 봉우리를 보강하여 크게 올록볼록한 형태가 나타난 것이다.반대로 보너스를 포함하지 않은 버전에서는, ‘보너스 성공 그래프’가 왼쪽으로 35점만큼 이동하여 봉우리끼리 상쇄된 효과가 발생했다.용의자 2: 고정 점수 카테고리최종 점수 그래프의 봉우리가 8개 나타난 이유는, 봉우리가 6개인 그래프 두 개가 합쳐진 결과라는 것을 확인했다. 그럼, 각 그래프가 6개 봉우리를 갖는 이유를 살펴보아야 한다. 주요인인 하단부 점수에 집중해 보자. 하단부 카테고리 중 점수가 고정된 세 가지 카테고리의 획득 여부에 따라 2×2×2=8가지 경우로 나누어 그래프를 그렸다. SS (Small Straight, 고정 15점) LS (Large Straight, 고정 30점) YT (Yacht, 고정 50점)각 경우마다 봉우리가 3개씩 있고, 이 그래프들이 합쳐져서 하단부 점수의 전체 분포가 형성되었다. Small Straight 점수 획득에 실패한 경우가 매우 드물어, 나머지 4가지 경우에 해당하는 그래프가 전체 그래프 영역의 대부분을 차지한 것을 볼 수 있다. Small Straight 점수 획득에 성공한 경우 4가지만 따로 분리하여 그래프를 그려보았다. 각 그래프의 형태는 거의 동일하며, 고정 점수의 차이에 따라 X축 상에서 위치만 달라졌다는 점이 눈에 띈다.용의자 3: 조건부 점수 카테고리위에서 확인했듯, 봉우리가 3개 있는 그래프 8개가 합쳐져서 봉우리가 6개 있는 하단부 점수의 분포가 만들어진 것이다. 마지막으로 고정 점수 카테고리 획득 여부가 동일한 경우 내에서 봉우리 3개가 나타나는 이유를 살펴보자. 위에서 나눈 경우의 수 중 가장 횟수가 많았던 SS성공 / LS성공 / YT실패 경우를 골라 더욱 세분된 통계를 내보았다. 점수를 조건부로 획득하는 세 가지 카테고리의 획득 여부에 따라 이번에도 2×2×2=8가지 경우로 나누어 그래프를 그려보았다. FH (Full House) 3K (3 of a Kind) 4K (4 of a Kind)각 경우에 해당하는 그래프에는 봉우리가 하나씩만 존재해, 더 이상 분해할 수 없는 최종 단위를 이룬다. 이 8개의 단일 봉우리가 합쳐져 3개의 봉우리가 있는 그래프 형태가 나타났다.아까와 비슷하게 3 of a Kind 점수 획득에 실패한 경우가 매우 드물어, 나머지 4가지 경우에 해당하는 그래프가 전체 그래프 영역의 대부분을 차지한 것을 볼 수 있다. 이번에도 3 of a Kind 점수 획득에 성공한 경우 4가지만 골라서 그래프를 분리하여 그려보았다. 고정 점수 카테고리 획득 여부에 따른 경우 분리와는 다르게, 각 그래프의 개형이 서로 다른 것을 볼 수 있다. 또한 포함한 성공 카테고리의 개수가 많을수록 좌우로 더 넓게 퍼진 형태를 나타낸다.흥미로운 점은, 두 번째와 세 번째 그래프가 X축 상에서 영역을 거의 공유한다는 점이다. 이로부터 Full House와 4 of a Kind 두 카테고리에서 얻는 평균 점수가 비슷하다는 것을 추정할 수 있다. 구체적으로는 Full House의 평균 점수가 살짝 더 높을 것이다. 이는 아래에서 확인해 보겠다.• 점수대별 카테고리 성공 여부 •Yacht 성공 여부 분포 약 150점 부근부터 성공 비율이 증가하기 시작한다. 270점대 이상 구간에서는 성공 비율이 사실상 100%에 가까운 것을 볼 수 있다. 이는 270점 이상의 고득점을 위해서는 Yacht 점수 획득이 필수적이라는 해석이 가능하다.Small Straight 성공 여부 분포 최종 점수 분포 그래프 분석에서 이미 예상했듯, 점수대 전체에 걸쳐 Small Straight 점수 획득에 실패한 비율은 매우 낮다. 100점대에서 실패 비율이 상대적으로 높은 것은, 해당 점수대 자체의 획득 빈도가 매우 낮아서 통계적 변동이 크게 반영된 결과로 추정된다.Large Straight 성공 여부 분포 Yacht에 비하면 매우 낮은 점수대인 105점대 근처에서 성공 비율이 증가하기 시작하여, 150점대만 넘어서면 성공 비율이 절반을 넘긴다. Yacht에 비하면 전반적으로 성공할 가능성이 훨씬 높고, 최종 점수에 영향을 덜 미친다는 것을 알 수 있다. (고정 획득 점수 자체가 더 낮으므로 당연한 결과이기도 하다.)조건부 점수 카테고리별 획득 점수 분포 조건부로 점수를 획득하는 세 카테고리에 대해 점수 획득 분포를 살펴보았다. 먼저 3 of a Kind는 점수 획득에 실패해 0점을 기록한 빈도가 다른 두 개 카테고리에 비해 현저히 적었다.앞서 Full House의 평균 점수가 4 of a Kind의 평균 점수보다 약간 더 높을 것으로 추정했는데, 각각 약 22점과 약 21점으로 확인되어 예측대로 들어맞았다.4 of a Kind와 Full House 모두에서 점수가 5의 배수인 경우의 빈도가 상대적으로 낮은 편이다. 이는 주사위 5개의 눈이 모두 동일해 합이 5의 배수가 되는 경우 대부분에서 Yacht를 선택했기 때문으로 보인다. 예외적으로 4 of A Kind에서 25점을 획득한 빈도는 그리 낮지 않은데, Choice를 위해 6을 노리다가 주사위가 [6, 6, 6, 6, 1]로 나오면 Choice보다 4 of a Kind를 선택하는 것이 유리했기 때문으로 추정해볼 수 있겠다.또한 Full House에서 29점을 획득한 빈도는 0이다. 주사위의 ‘2개의 눈이 동일하고 나머지 3개의 눈이 동일한’ Full House의 조합에서 눈의 합이 29가 나오는 경우의 수가 존재하지 않기 때문이다.• 가중치별 점수 분포 비교 •지난 게시글에서 상단부 점수에 가중치 3.0을 적용해 최적 선택 로직을 완성했다고 언급했다. 지금까지 살펴본 통계들은 가중치 3.0으로 시뮬레이션한 결과이다. 그러나 가중치 설정값에 따라 점수 분포가 어떻게 달라질지도 궁금했으므로, 가중치를 1.0으로 세팅한 경우의 플레이 결과와 간단히 비교해 보았다.최종 점수 분포 비교 가중치가 1일 때는 봉우리의 개수뿐 아니라 전체 그래프의 형태도 크게 달라졌다. 이는 전체 분포를 세부적인 경우로 분리해 보았을 때, 각 봉우리가 겹치며 보강되거나 상쇄되는 방식이 가중치에 따라 달라졌기 때문으로 보인다.상단부 점수 분포 비교 상단부 점수 분포의 형태는 여전히 정규분포와 유사한 단봉형 분포로 나타난다. 그러나 가중치가 1.0인 로직은 상단부 점수의 가치를 더 낮게 평가하므로 평균 점수가 더 낮고, 결과적으로 그래프 전체가 왼쪽으로 이동한 모습을 보인다.하단부 점수 분포 비교 하단부에서는 가중치가 1.0일 때 봉우리가 5개로 줄었으며, 각 봉우리의 획득 빈도도 들쑥날쑥하다. 만약 가중치가 3.0인 경우와 동일하게 경우를 나눠서 그래프를 그려본다면, 봉우리 간의 보강과 상쇄가 다르게 일어나 이런 차이가 생긴다는 결론에 도달할 것이다.우리는 가중치가 3.0으로 세팅된 로직을 사용할 예정이므로, 가중치 1.0으로 얻은 통계에 대한 분석은 여기서 마무리하겠다." }, { "title": "[Pancht] 요트 다이스 최적 선택 알고리즘을 구현한 방법", "url": "/posts/yacht-dice-optimal-selection-algorithm/", "categories": "Development Log", "tags": "Pancht, Algorithm, Dynamic Programming, Bitmasking", "date": "2024-12-31 00:00:00 +0900", "snippet": "• 서론 •왜 하게 되었는가요트 다이스의 룰을 차용한 Pancht라는 게임에 AI 대전 모드를 넣게 되었다. 이 AI는 숙련된 플레이어의 실력에 준하는, 또는 그 이상의 실력을 갖춰야 고티어 플레이어와 유의미한 대결이 가능할 것이다.숙련된 플레이어의 의사 결정을 모방해서 로직을 직접 작성하는 방법도 있겠지만 코드가 매우 복잡해질 것으로 예상되었고, 이후 설명할 방식에 비하면 획득할 수 있는 최종 점수의 기댓값이 낮을 것 같았다. 따라서 플레이 종료 시점까지의 미래를 전부 계산하여 항상 최적의 선택을 하는 AI 알고리즘을 짜서 구현하기로 했다. (저티어 플레이어를 위한 실력 조절에 대해서는 추후 포스팅 예정)요트 다이스 게임을 하며 플레이어가 주사위를 굴린 직후, 마주할 수 있는 경우의 수를 계산해보자. 카테고리가 총 13개라면, 각 카테고리가 채워졌는지 여부에 따른 경우의 수는 2^13 = 8192가지이다. (정확히 계산하려면 모든 카테고리가 채워진 상태에는 더 이상 주사위를 굴리지 않으므로 1을 빼야 하지만 편의를 위해 생략했다) 주사위를 최대 두 번 리롤할 수 있으므로, 한 턴에 주사위를 굴리는 횟수는 최대 3번이다. 따라서 주사위를 굴리는 횟수로 인한 경우의 수는 3가지이다. 그리고 6면체 주사위를 5개 굴리므로, 중복 조합으로 계산했을 때 주사위에서 나올 수 있는 경우의 수는 6H5 = 252가지이다.즉, 8192 x 3 x 252 = 6,193,152가지의 경우의 수에 대한 모든 최적 행동을 구하는 알고리즘을 짜면, 게임의 어디에서든 구해놓은 최적 행동을 이용해서 플레이가 가능할 것이다.어떻게 구현했는가 모든 가능한 행동을 하나씩 다 수행해본다. 즉, 카테고리 선택을 하거나, 주사위 일부 또는 전부를 리롤한다. 그 행동을 취한 후 주사위를 굴렸을 때 나올 수 있는 모든 주사위의 조합에 대해 시뮬레이션하여, 얻을 수 있는 점수의 기댓값을 계산한다. 카테고리 선택을 한 경우: 다음 턴이 시작되어 주사위를 새로 굴리므로 주사위 눈의 조합 252개 전체에 대해 시뮬레이션한다. 리롤하는 경우: 리롤하기로 택한 주사위에 따라 나올 수 있는 모든 경우의 수에 대해 시뮬레이션 한다. 위에서 구한 점수 기댓값 중 가장 높은 기댓값을 갖는 행동을 선택한다. 즉, 점수 기댓값이 가장 높은 상태로 이동하는 행동을 취한다. 주사위를 굴릴 때마다 위 작업을 반복하면 항상 최선의 선택을 할 수 있을 것이다.그러나 각 행동에서 얻을 수 있는 최고 점수를 알기 위해서는, 해당 시점부터 게임 종료까지 발생할 수 있는 모든 행동과 주사위 경우의 수를 전부 탐색해야 한다. 이 방식을 나이브하게 구현하면, 코드 실행에 상상도 못 할 정도로 오랜 시간이 걸릴 것이다. 따라서 최적화가 필요하다.어떻게 최적화했는가위에서 구한 약 6백만 가지의 경우의 수에는 방향성이 있다. 게임을 플레이할 때는 항상 카테고리가 점점 많이 채워지는 방향으로 진행하기 때문이다.즉, 어떤 상황에서 최적 행동을 구하기 위해 ‘현재 상황보다 카테고리가 적게 채워진 상태’의 기댓값은 알 필요가 없다. 그런 상태는 이미 과거에 지나쳤거나, 현재 상황과는 무관한 상태이기 때문이다.하지만 ‘현재 상황보다 카테고리가 많이 채워진 상태’, 즉 미래에 발생할 수 있는 어떤 상태의 기댓값은 현재의 최적 행동을 구하기 위해 꼭 필요한 정보다.게임의 종료에 가까운 상태의 기댓값은, 그보다 종료에 덜 가까운 상태의 최적 행동 계산에 필요하다. 또한 어떤 상태의 기댓값은 여러 번 참조될 수 있다.따라서 어떤 상태의 기댓값을 계산하게 되면 그 값을 저장해두고, 나중에 필요할 때는 다시 계산하지 않고 저장해둔 값을 재활용함으로써 수행 시간을 획기적으로 줄일 수 있다. 바로 다이나믹 프로그래밍(DP)을 사용하는 것이다.주의 사항 여기서 보관하는 값은 행동에 대한 기댓값이 아닌, 상태에 대한 기댓값이다. 어떤 상태에서 행동을 취함으로써 또 다른 상태로 이동하게 된다. 이동할 수 있는 상태들의 기댓값들을 비교하여 어느 상태로 이동할지 결정하는 것이 곧 어떤 행동을 선택할지 결정하는 것과 같다. 어떤 상태의 기댓값이란 그 상태에서 게임을 시작했다고 가정하고, 게임 종료에 도달했을 때까지 얻을 수 있는 점수의 기댓값이라는 의미이다. 그 상태가 되기 이전에 얻은 점수는 포함하지 않는다.• PanchtAI.h •#ifndef PANCHT_AI_H#define PANCHT_AI_Henum Category { ACES, TWOS, THREES, FOURS, FIVES, SIXES, CHOICE, THREE_OF_A_KIND, FOUR_OF_A_KIND, FULL_HOUSE, SMALL_STRAIGHT, LARGE_STRAIGHT, YACHT, NONE};struct DicesInfo { int dices[5]; int&amp;amp; operator[](int idx) { return dices[idx]; }};constexpr int ANS_6_POW[5] = { 1, 6, 36, 216, 1296 };constexpr int ANS_6_POW_5 = 7776;constexpr int ANS_2_POW_5 = 32;constexpr int ANS_2_POW_13 = 8192;constexpr int CATEGORY_CNT = 13;constexpr int DICE_CNT = 5;constexpr int DICE_CASE_CNT = 252; // = 6H5 = 10C5extern const char* categoryNames[];extern int8_t bestAction[ANS_2_POW_13][3][DICE_CASE_CNT];extern double aiScoreWeight;extern void initComb();extern void initArrays();extern int getEarnedScore(Category category, DicesInfo dicesInfo, bool forAI);extern int convertDicesInfoToInt(DicesInfo&amp;amp; diceInfo);extern void convertDiceIntToInfo(int idx, DicesInfo&amp;amp; dices);extern int convertActionInfoToInt(Category category, int rerollMask);extern void convertActionIntToInfo(int actionInt, Category&amp;amp; category, int&amp;amp; rerollMask);extern void calBestActionAndScore(int categoryMask, int rerolledCnt, DicesInfo dicesInfo);#endif최적 선택 로직이 필요한 코드에서 공용으로 사용할 헤더 파일을 만들었다. 이 파일에는 카테고리 열거형과 주사위 눈 정보 구조체, 그리고 일부 상수, 배열, 함수 선언이 포함되어 있다.각 함수의 구현 세부 내용은 뒤에서 소개할 PanchtAI.cpp 코드 설명에서 다루겠다.• PanchtAI.cpp의 배열들 •combTable[]static int combTable[20][20];조합 연산이 필요한 부분에서 빠르게 참조할 수 있도록, 미리 계산한 값을 저장해둔 배열이다. combTable[n][m]을 참조하면 nCm의 값을 얻을 수 있다.bestAction[]int8_t bestAction[ANS_2_POW_13][3][DICE_CASE_CNT];bestAction 배열은 위에서 말한 약 6백만 가지의 상태 각각에 대한 최적 행동을 저장하는 3차원 배열이다.최적 행동을 하나의 정수로 인코딩하는 방법은 이후 나올 함수 구현 설명에서 자세히 다루겠다. 첫 번째 인자: 각 카테고리 선택 여부를 정수로 변환한 값 (0~8191) 두 번째 인자: 해당 턴에 리롤한 횟수를 나타낸 값 (0~2) 세 번째 인자: 주사위 5개의 상태를 하나의 정수로 변환해 나타낸 값 (0~251)bestScore[]double bestScore[ANS_2_POW_13][3][DICE_CASE_CNT];bestScore 배열은 약 6백만 가지의 상태 각각에서 얻을 수 있는 최대 기댓값을 저장한다. 각 인자들의 의미는 bestAction 배열과 동일하다.게임 후반으로 갈수록 각 상태의 기댓값 차이가 미미해지므로 소수점 아래 값이 중요해진다. 처음에는 이 값을 int로 저장했었는데, 이렇게 하면 기댓값의 정수 부분이 동일한 행동들 중 코드상에서 먼저 계산하는 행동을 선택하게 된다. 그 결과, 리롤을 하지 않고 카테고리 선택을 성급하게 해버리는 경향이 있었다. 이 문제는 자료형을 double로 변경하며 기댓값 손실을 방지하여 해결되었다.avgScore[]double avgScore[ANS_2_POW_13];avgScore 배열은 2^13 = 8192가지의 카테고리 선택 여부에 따라 턴 시작 시점에서 얻을 수 있는 기댓값을 저장한다.avgScore2[]double avgScore2[ANS_2_POW_13][3][DICE_CASE_CNT][ANS_2_POW_5];avgScore2 배열은 약 6백만 가지의 상태 각각에서 리롤하는 모든 선택지에 대한 기댓값을 저장한다. 첫 번째 인자: 각 카테고리 선택 여부를 정수로 변환한 값 (0~8191) 두 번째 인자: 해당 턴에 리롤한 횟수를 나타낸 값 (0~2) 세 번째 인자: 주사위 5개의 상태를 하나의 정수로 변환해 나타낸 값 (0~251) 네 번째 인자: 리롤할 주사위 선택 여부를 하나의 정수로 나타낸 값 (0~31)• PanchtAI.cpp의 함수들 •initComb() &amp;amp; comb()void initComb() { for (int i = 0; i &amp;lt; 20; i++) { combTable[i][0] = 1; for (int j = 1; j &amp;lt;= i; j++) { combTable[i][j] = combTable[i - 1][j - 1] + combTable[i - 1][j]; } }}int comb(int n, int k) { if (k &amp;gt; n || k &amp;lt; 0) return 0; return combTable[n][k];}처음 프로그램 실행 시 initComb()를 한 번 호출하여 미리 combTable 배열을 초기화한다.이후 어디서든 comb()를 호출해 조합 연산의 결과를 빠르게 사용할 수 있도록 작성했다.initArrays()void initArrays() { for (int i = 0; i &amp;lt; ANS_2_POW_13; i++) { avgScore[i] = -1.0; for (int j = 0; j &amp;lt; 3; j++) { for (int k = 0; k &amp;lt; DICE_CASE_CNT; k++) { bestAction[i][j][k] = -1; bestScore[i][j][k] = -1.0; for (int l = 0; l &amp;lt; ANS_2_POW_5; l++) { avgScore2[i][j][k][l] = -1.0; } } } }}위에서 설명한 여러 DP 배열의 모든 원소를 -1로 초기화하는 함수이다. initComb()와 마찬가지로 프로그램 처음 실행 시 한 번 호출해야 한다.이후, 이 배열들을 참조할 때 값이 -1이라면 아직 계산되지 않았음을 의미하므로 새로 계산해야 하고, -1이 아니라면 이미 계산된 것이므로 그대로 재활용한다.getEarnedScore()int getEarnedScore(Category category, DicesInfo dicesInfo, bool forAI = true) { if (ACES &amp;lt;= category &amp;amp;&amp;amp; category &amp;lt;= SIXES) { int score = 0; for (int i = 0; i &amp;lt; 5; i++) { if (dicesInfo.dices[i] == category + 1) score += category + 1; } if (forAI) return score * aiScoreWeight; return score; } int totSum = 0; for (int i = 0; i &amp;lt; 5; i++) totSum += dicesInfo.dices[i]; int numFreq[7] = { 0 }; for (int i = 0; i &amp;lt; 5; i++) numFreq[dicesInfo.dices[i]]++; if (category == CHOICE) { return totSum; } if (category == THREE_OF_A_KIND) { for (int i = 1; i &amp;lt;= 6; i++) { if (numFreq[i] &amp;gt;= 3) return totSum; } return 0; } if (category == FOUR_OF_A_KIND) { for (int i = 1; i &amp;lt;= 6; i++) { if (numFreq[i] &amp;gt;= 4) return totSum; } return 0; } if (category == FULL_HOUSE) { bool hasThree = false, hasTwo = false, hasFive = false; for (int i = 1; i &amp;lt;= 6; i++) { if (numFreq[i] == 3) hasThree = true; if (numFreq[i] == 2) hasTwo = true; if (numFreq[i] == 5) hasFive = true; } if (hasThree &amp;amp;&amp;amp; hasTwo || hasFive) return totSum; return 0; } if (category == SMALL_STRAIGHT) { for (int i = 1; i &amp;lt;= 3; i++) { bool isSmallStraight = true; for (int j = i; j &amp;lt; i + 4; j++) { if (numFreq[j] == 0) { isSmallStraight = false; break; } } if (isSmallStraight) return 15; } return 0; } if (category == LARGE_STRAIGHT) { for (int i = 1; i &amp;lt;= 2; i++) { bool isLargeStraight = true; for (int j = i; j &amp;lt; i + 5; j++) { if (numFreq[j] == 0) { isLargeStraight = false; break; } } if (isLargeStraight) return 30; } return 0; } if (category == YACHT) { for (int i = 1; i &amp;lt;= 6; i++) { if (numFreq[i] == 5) return 50; } return 0; } return 0;}선택한 카테고리와 주사위 눈 정보를 넘기면 그 카테고리에서 해당 주사위 눈으로 얻을 수 있는 점수를 반환하는 함수이다.convertDicesInfoToInt()int convertDicesInfoToInt(DicesInfo&amp;amp; dicesInfo) { int freq[6] = { 0 }; for (int i = 0; i &amp;lt; DICE_CNT; i++) { freq[dicesInfo[i] - 1]++; } int idx = 0, remain = 5; for (int i = 0; i &amp;lt; 6; i++) { int x = freq[i]; for (int skip_val = 0; skip_val &amp;lt; x; skip_val++) { int ways = comb(remain - skip_val + 5 - i - 1, 5 - i - 1); idx += ways; } remain -= x; } return idx;}주사위 다섯 개의 눈 정보를 받아 0부터 251 사이의 정수로 매핑하는 함수이다. 이를 통해 주사위 눈 정보를 배열의 인덱스로 직접 사용할 수 있게 해준다.원래 주사위 5개에서 나올 수 있는 경우의 수는 6^5 = 7776가지이지만, 이 게임에서는 주사위 눈의 순서가 중요하지 않다. 순서를 무시하고 오름차순으로 정렬했을 때는 경우의 수가 252가지로 줄어든다. 이 점을 활용해 0~251 범위로 오름차순 매핑하였다.convertDiceIntToInfo()void convertDiceIntToInfo(int idx, DicesInfo&amp;amp; dices) { int freq[6] = { 0 }; int remain = 5; for (int i = 0; i &amp;lt; 6; i++) { int x = 0; while (true) { if (remain - x &amp;lt; 0) break; int ways = comb(remain - x + (5 - i) - 1, (5 - i) - 1); if (ways == 0) { x++; continue; } if (ways &amp;gt; idx) { freq[i] = x; remain -= x; break; } else { idx -= ways; x++; } } } dices = { 6, 6, 6, 6, 6 }; int pos = 0; for (int face = 0; face &amp;lt; 6; face++) { for (int count = 0; count &amp;lt; freq[face]; count++) { dices[pos++] = face + 1; } }}매핑된 주사위 눈 정수를 받아 다시 5개의 주사위 눈 정보로 변환하는 함수이다. 항상 오름차순으로 정렬된 주사위 눈 정보를 반환한다.convertActionInfoToInt()int convertActionInfoToInt(Category category, int rerollMask) { if (category != NONE) return category; return 12 + rerollMask;}카테고리 정보와 리롤 주사위 정보를 각각 정수로 입력받아, 행동을 하나의 정수로 압축하여 반환한다. 하나의 행동에는 ‘카테고리 선택’ 또는 ‘리롤’ 중 한 가지만 포함될 수 있으므로, 이 함수를 호출할 때는 무조건 category를 NONE으로 하거나 rerollMask를 0으로 설정해야 한다.반환값은 0~44 범위를 갖는다. 0~12: 특정 카테고리 선택 13~44: 주사위 일부 또는 전체를 리롤convertActionIntToInfo()void convertActionIntToInfo(int actionInt, Category&amp;amp; category, int&amp;amp; rerollMask) { if (actionInt &amp;lt;= 12) { category = (Category)actionInt; rerollMask = 0; return; } category = NONE; rerollMask = actionInt - 12;}압축된 행동 정수를 다시 카테고리 정보 또는 리롤 주사위 정보로 변환하는 함수이다.getAvgScore(categoryMask)double getAvgScore(int categoryMask) { if (avgScore[categoryMask] &amp;gt;= 0) return avgScore[categoryMask]; double sum = 0; for (int diceInfoInt = 0; diceInfoInt &amp;lt; DICE_CASE_CNT; diceInfoInt++) { DicesInfo dicesInfo; convertDiceIntToInfo(diceInfoInt, dicesInfo); calBestActionAndScore(categoryMask, 0, dicesInfo); sum += bestScore[categoryMask][0][diceInfoInt]; } return avgScore[categoryMask] = sum / DICE_CASE_CNT;}위에서 언급한 avgScore 배열에 대응하는 DP 함수이다. 주어진 카테고리 선택 여부에서 턴을 시작한 시점에 얻을 수 있는 기댓값을 반환하는 함수이다. 이를 위해 가능한 252가지 주사위 결과를 모두 시뮬레이션하고, 각 결과의 최대 기댓값들의 평균을 반환함으로써 원하는 값을 얻는다.getAvgScore(categoryMask, rerolledCnt, dicesInfo, rerollMask)double getAvgScore(int categoryMask, int rerolledCnt, DicesInfo dicesInfo, int rerollMask) { int dicesInfoInt = convertDicesInfoToInt(dicesInfo); double&amp;amp; crAvgScore = avgScore2[categoryMask][rerolledCnt][dicesInfoInt][rerollMask]; if (crAvgScore &amp;gt;= 0) return crAvgScore; int rerollIdx[5]; int rerollCnt = 0; for (int i = 0; i &amp;lt; DICE_CNT; i++) { if ((rerollMask &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0) continue; rerollIdx[rerollCnt++] = i; } int rerollCaseCnt = 1; for (int i = 0; i &amp;lt; rerollCnt; i++) rerollCaseCnt *= 6; double sum = 0; for (int caseInt = 0; caseInt &amp;lt; rerollCaseCnt; caseInt++) { DicesInfo newDices = dicesInfo; int tmp = caseInt; for (int j = 0; j &amp;lt; rerollCnt; j++) { int roll = (tmp % 6) + 1; tmp /= 6; newDices[rerollIdx[j]] = roll; } calBestActionAndScore(categoryMask, rerolledCnt + 1, newDices); int newDicesInt = convertDicesInfoToInt(newDices); sum += bestScore[categoryMask][rerolledCnt + 1][newDicesInt]; } return crAvgScore = sum / rerollCaseCnt;}위에서 언급한 avgScore2 배열에 대응하는 DP 함수이다. 각 카테고리 선택 여부, 리롤 횟수, 주사위 눈 정보, 그리고 리롤할 주사위 정보를 받아서 해당 리롤을 수행했을 때 얻게 되는 기댓값을 반환하는 함수이다. 마찬가지로 리롤 후 가능한 주사위의 결과를 모두 시뮬레이션하고, 각 결과의 최대 기댓값들의 평균을 반환함으로써 원하는 값을 얻는다.calBestActionAndScore()void calBestActionAndScore(int categoryMask, int rerolledCnt, DicesInfo dicesInfo) { int dicesInfoInt = convertDicesInfoToInt(dicesInfo); int8_t&amp;amp; crBestAction = bestAction[categoryMask][rerolledCnt][dicesInfoInt]; double&amp;amp; crBestScore = bestScore[categoryMask][rerolledCnt][dicesInfoInt]; sort(dicesInfo.dices, dicesInfo.dices + DICE_CNT); //이미 계산한/불러온 케이스인 경우 계산 결과 반환 if (crBestAction != -1) return; int remainCategoryCnt = 0; for (int i = 0; i &amp;lt; CATEGORY_CNT; i++) { if ((categoryMask &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0) remainCategoryCnt++; } //카테고리가 1개 남았고 3번째 굴림인 경우 해당 카테고리 반환 if (remainCategoryCnt == 1 &amp;amp;&amp;amp; rerolledCnt == 2) { Category onlyCategory = NONE; for (int i = 0; i &amp;lt; CATEGORY_CNT; i++) { if ((categoryMask &amp;amp; (1 &amp;lt;&amp;lt; i)) != 0) continue; onlyCategory = (Category)i; break; } crBestAction = convertActionInfoToInt(onlyCategory, 0); crBestScore = getEarnedScore(onlyCategory, dicesInfo, true); return; } //========== 모든 경우의 수에 대해 최대 기댓값을 얻는 액션 찾기 ========== Category bestCategory = NONE; int bestRerollMask = 0; double bestAvgScore = 0; //카테고리를 선택하는 경우 for (int i = 0; i &amp;lt; CATEGORY_CNT; i++) { if ((categoryMask &amp;amp; (1 &amp;lt;&amp;lt; i)) != 0) continue; Category crCategory = (Category)i; double crAvgScore = getEarnedScore(crCategory, dicesInfo, true) + getAvgScore(categoryMask | (1 &amp;lt;&amp;lt; i)); if (crAvgScore &amp;gt; bestAvgScore) { bestAvgScore = crAvgScore; bestCategory = crCategory; bestRerollMask = 0; } } if (rerolledCnt == 2) { crBestAction = convertActionInfoToInt(bestCategory, 0); crBestScore = bestAvgScore; return; } //리롤하는 경우 for (int rerollMask = 1; rerollMask &amp;lt; ANS_2_POW_5; rerollMask++) { double crAvgScore = getAvgScore(categoryMask, rerolledCnt, dicesInfo, rerollMask); if (crAvgScore &amp;gt; bestAvgScore) { bestAvgScore = crAvgScore; bestCategory = NONE; bestRerollMask = rerollMask; } } crBestAction = convertActionInfoToInt(bestCategory, bestRerollMask); crBestScore = bestAvgScore;}위에서 언급한 bestAction 배열과 bestScore 배열에 대응하는 DP 함수이자 가장 중요한 함수이다. 각 카테고리 선택 여부, 리롤 횟수, 주사위 눈 정보를 인자로 받는다. 즉, 주사위를 굴린(또는 리롤한) 직후 상태를 총 3개의 인자로써 나타낸 것이다.플레이어가 취할 수 있는 행동은 크게 두 가지가 있다. 빈 카테고리를 선택한다 (리롤 횟수가 2보다 작다면) 주사위 일부 또는 전체를 골라 리롤한다함수는 이 두 종류의 가능한 모든 행동을 시도해 본 뒤, 각각의 행동을 통해 이동하게 될 다음 상태의 기댓값들을 모두 계산 및 비교한다. 그리고 그 중 그 기댓값이 가장 큰 행동과 그 점수를 동시에 반환한다.• PanchtPlayer.cpp •소스코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;fstream&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;ctime&amp;gt;#include &quot;PanchtAI.h&quot;using namespace std;DicesInfo getRandomDices() { DicesInfo dicesInfo; for (int i = 0; i &amp;lt; DICE_CNT; i++) { dicesInfo[i] = rand() % 6 + 1; } sort(dicesInfo.dices, dicesInfo.dices + DICE_CNT); return dicesInfo;}DicesInfo getRandomRerolledDices(DicesInfo dicesInfo, int&amp;amp; rerollMask) { for (int i = 0; i &amp;lt; DICE_CNT; i++) { if (rerollMask &amp;amp; (1 &amp;lt;&amp;lt; i)) { dicesInfo[i] = rand() % 6 + 1; } } sort(dicesInfo.dices, dicesInfo.dices + DICE_CNT); return dicesInfo;}string diceInfoString(DicesInfo dicesInfo) { string str = &quot;&quot;; for (int i = 0; i &amp;lt; DICE_CNT; i++) { str += (dicesInfo[i] + &#39;0&#39;); if (i != DICE_CNT - 1) str += &quot;, &quot;; } return str;}void printRerollMask(int rerollMask) { string str = &quot;rerollMask: &quot;; for (int i = 0; i &amp;lt; DICE_CNT; i++) { str += (rerollMask &amp;amp; (1 &amp;lt;&amp;lt; i)) ? &#39;1&#39; : &#39;0&#39;; } cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &#39;\\n&#39;;}bool selectAction(int rerolledCnt, int&amp;amp; score, int&amp;amp; numScore, DicesInfo&amp;amp; dicesInfo, int&amp;amp; categoryMask, Category&amp;amp; bestCategory, int&amp;amp; bestRerollMask) { calBestActionAndScore(categoryMask, rerolledCnt, dicesInfo); int dicesInfoInt = convertDicesInfoToInt(dicesInfo); int bestActionInt = bestAction[categoryMask][rerolledCnt][dicesInfoInt]; convertActionIntToInfo(bestActionInt, bestCategory, bestRerollMask); if (bestCategory == NONE) { printRerollMask(bestRerollMask); return false; } int crScore = getEarnedScore(bestCategory, dicesInfo, false); cout &amp;lt;&amp;lt; &quot;선택한 카테고리: &quot; &amp;lt;&amp;lt; categoryNames[bestCategory] &amp;lt;&amp;lt; &#39;\\n&#39;; cout &amp;lt;&amp;lt; &quot;획득한 점수: &quot; &amp;lt;&amp;lt; crScore &amp;lt;&amp;lt; &quot;\\n\\n&quot;; score += crScore; if (ACES &amp;lt;= bestCategory &amp;amp;&amp;amp; bestCategory &amp;lt;= SIXES) numScore += crScore; categoryMask |= (1 &amp;lt;&amp;lt; bestCategory); return true;}int playGame() { int categoryMask = 0, score = 0, numScore = 0; for (int turn = 1; turn &amp;lt;= CATEGORY_CNT; turn++) { cout &amp;lt;&amp;lt; &quot;&amp;lt;&quot; &amp;lt;&amp;lt; turn &amp;lt;&amp;lt; &quot;번째 턴 시작&amp;gt;&quot; &amp;lt;&amp;lt; &#39;\\n&#39;; Category bestCategory; int bestRerollMask; DicesInfo dicesInfo = getRandomDices(); cout &amp;lt;&amp;lt; &quot;첫 번째 롤: &quot; &amp;lt;&amp;lt; diceInfoString(dicesInfo) &amp;lt;&amp;lt; &#39;\\n&#39;; if (selectAction(0, score, numScore, dicesInfo, categoryMask, bestCategory, bestRerollMask)) continue; dicesInfo = getRandomRerolledDices(dicesInfo, bestRerollMask); cout &amp;lt;&amp;lt; &quot;두 번째 롤: &quot; &amp;lt;&amp;lt; diceInfoString(dicesInfo) &amp;lt;&amp;lt; &#39;\\n&#39;; if (selectAction(1, score, numScore, dicesInfo, categoryMask, bestCategory, bestRerollMask)) continue; dicesInfo = getRandomRerolledDices(dicesInfo, bestRerollMask); cout &amp;lt;&amp;lt; &quot;세 번째 롤: &quot; &amp;lt;&amp;lt; diceInfoString(dicesInfo) &amp;lt;&amp;lt; &#39;\\n&#39;; selectAction(2, score, numScore, dicesInfo, categoryMask, bestCategory, bestRerollMask); } if (numScore &amp;gt;= 63) score += 35; cout &amp;lt;&amp;lt; &quot;최종 점수: &quot; &amp;lt;&amp;lt; score &amp;lt;&amp;lt; &quot;\\n\\n&quot;; return score;}int main() { srand(time(NULL)); initComb(); initArrays(); int crScore = playGame(); cout &amp;lt;&amp;lt; &quot;최종 점수: &quot; &amp;lt;&amp;lt; crScore &amp;lt;&amp;lt; &quot;\\n&quot;; return 0;}이 코드를 실행하면 요트 다이스 게임 플레이 시뮬레이션을 수행한다. 실제 플레이 방식을 모방하면서, 행동을 선택해야 할 때마다 calBestActionAndScore() 함수를 호출해서 최적 행동을 결정한다.카테고리 선택 여부와 리롤할 주사위는 비트마스킹을 활용해 각각 하나의 정수로 표현했다.실행 결과&amp;lt;1번째 턴 시작&amp;gt;첫 번째 롤: 2, 2, 5, 5, 6rerollMask: 11001두 번째 롤: 1, 1, 3, 5, 5rerollMask: 11100세 번째 롤: 2, 5, 5, 6, 6선택한 카테고리: Choice획득한 점수: 24&amp;lt;2번째 턴 시작&amp;gt;첫 번째 롤: 1, 1, 1, 2, 4rerollMask: 00011두 번째 롤: 1, 1, 1, 1, 3rerollMask: 00001세 번째 롤: 1, 1, 1, 1, 3선택한 카테고리: Aces획득한 점수: 4&amp;lt;3번째 턴 시작&amp;gt;첫 번째 롤: 1, 1, 2, 2, 6rerollMask: 11001두 번째 롤: 2, 2, 2, 3, 4rerollMask: 00011세 번째 롤: 1, 2, 2, 2, 2선택한 카테고리: Twos획득한 점수: 8&amp;lt;4번째 턴 시작&amp;gt;첫 번째 롤: 1, 3, 4, 5, 5rerollMask: 10010두 번째 롤: 3, 3, 4, 4, 5rerollMask: 10100세 번째 롤: 3, 3, 3, 4, 5선택한 카테고리: Threes획득한 점수: 9&amp;lt;5번째 턴 시작&amp;gt;첫 번째 롤: 1, 2, 4, 5, 5rerollMask: 11100두 번째 롤: 1, 3, 5, 5, 5rerollMask: 11000세 번째 롤: 4, 5, 5, 5, 5선택한 카테고리: Fives획득한 점수: 20&amp;lt;6번째 턴 시작&amp;gt;첫 번째 롤: 1, 2, 3, 3, 5rerollMask: 10100두 번째 롤: 1, 2, 3, 3, 5rerollMask: 10100세 번째 롤: 1, 2, 3, 4, 5선택한 카테고리: LargeStraight획득한 점수: 30&amp;lt;7번째 턴 시작&amp;gt;첫 번째 롤: 1, 3, 3, 4, 5rerollMask: 11000두 번째 롤: 1, 3, 3, 4, 5rerollMask: 11000세 번째 롤: 2, 3, 4, 4, 5선택한 카테고리: SmallStraight획득한 점수: 15&amp;lt;8번째 턴 시작&amp;gt;첫 번째 롤: 2, 3, 5, 5, 5rerollMask: 11000두 번째 롤: 2, 5, 5, 5, 5rerollMask: 10000세 번째 롤: 5, 5, 5, 5, 5선택한 카테고리: Yacht획득한 점수: 50&amp;lt;9번째 턴 시작&amp;gt;첫 번째 롤: 2, 2, 3, 3, 5rerollMask: 11111두 번째 롤: 1, 2, 4, 5, 6rerollMask: 11011세 번째 롤: 2, 2, 3, 4, 6선택한 카테고리: FullHouse획득한 점수: 0&amp;lt;10번째 턴 시작&amp;gt;첫 번째 롤: 2, 3, 4, 6, 6rerollMask: 11100두 번째 롤: 3, 5, 6, 6, 6rerollMask: 11000세 번째 롤: 3, 5, 6, 6, 6선택한 카테고리: Sixes획득한 점수: 18&amp;lt;11번째 턴 시작&amp;gt;첫 번째 롤: 1, 2, 2, 2, 5rerollMask: 10001두 번째 롤: 2, 2, 2, 2, 3rerollMask: 00001세 번째 롤: 2, 2, 2, 2, 4선택한 카테고리: FourOfAKind획득한 점수: 12&amp;lt;12번째 턴 시작&amp;gt;첫 번째 롤: 1, 3, 4, 4, 6rerollMask: 11001두 번째 롤: 3, 4, 4, 4, 6rerollMask: 10001세 번째 롤: 3, 4, 4, 4, 4선택한 카테고리: Fours획득한 점수: 16최종 점수: 241플레이어가 실제로 전략적인 선택을 하는 듯한 모습을 확인했다. 지금까지 짠 코드가 예상대로 동작했음을 알 수 있다.테스트로 5000회 실행했을 때의 평균 점수는 205.695점으로, 준수한 결과가 나왔다.(참고: DP로 최적화를 했음에도 불구하고 이 코드를 한 번 실행하는 데에 5시간 40분이 소요되었다.)• 가중치 세팅 •그러나, 최적 선택 로직에 보너스 점수 획득이 반영되지 않았다는 한 가지 문제가 남아 있다. 물론 실제 게임 플레이 시뮬레이션에서 최종 점수를 계산할 때는 보너스 점수를 추가해 주지만, 행동 선택 로직에서는 이 보너스를 무시하고 있기 때문이다.즉, 카테고리 중 Aces부터 Sixes까지의 획득 점수의 가치가 실제보다 과소평가되고 있다고 볼 수 있다.실제로 보너스를 고려해서 완벽한 최적 선택을 구현할 수도 있겠지만, 그러면 코드가 매우 복잡해지고 실행 시간도 훨씬 길어질 것이다. 따라서 최적 행동을 선택할 때, Aces부터 Sixes의 획득 점수에 1보다 큰 가중치를 부여하여 최적 선택의 근사치를 얻는 방식을 시도해 보았다.최적의 가중치를 찾기 위해 가중치를 변화시키면서 5천회씩 플레이하여 평균 점수를 구했다.가중치: 1.0, 평균 점수: 205.695가중치: 1.5, 평균 점수: 208.052가중치: 2.0, 평균 점수: 211.364가중치: 2.5, 평균 점수: 211.856가중치: 3.0, 평균 점수: 211.476가중치: 3.5, 평균 점수: 211.819가중치: 4.0, 평균 점수: 209.800가중치: 4.5, 평균 점수: 209.331가중치: 5.0, 평균 점수: 207.742가중치: 5.5, 평균 점수: 206.187가중치: 6.0, 평균 점수: 203.849예상대로 가중치가 1부터 일정값에 도달할 때까지는 평균 점수가 높아졌다가, 그 후로는 다시 낮아지는 경향성이 보인다. 가중치 2.5와 3.5에서 평균 점수가 가장 높고, 3.0에서는 살짝 낮아졌는데, 이는 5천 회의 시뮬레이션 실행으로는 이상치의 영향을 받았기 때문이라고 판단된다.결국 가중치를 3.0으로 결정함으로써 로직 구현이 완료되었다.(참고: 이 게임은 한 판에서 발생하는 랜덤 요소가 매우 많기 때문에 5천 회 정도의 테스트 횟수는 부족하며, 천만 회 정도는 테스트해야 통계적으로 안정적인 결과를 얻을 수 있다는 사실을 뒤늦게 알았다.)• 저장 및 불러오기 •저장하기매번 플레이할 때마다 5시간 40분씩 코드를 돌릴 수는 없다. 따라서 bestAction 배열의 결괏값들을 미리 계산해서 저장해 둔 뒤, 이를 불러와서 사용하기로 했다.int main() { initComb(); initArrays(); aiScoreWeight = 3.0f; ofstream outFile(&quot;bestAction.bin&quot;, ios::binary); if (!outFile.is_open()) { printf(&quot;bestAction.bin 파일 오픈 실패\\n&quot;); return 1; } printf(&quot;bestAction.bin 파일 오픈 성공\\n&quot;); static int8_t data[ANS_2_POW_13 * 3 * DICE_CASE_CNT]; for (int i = ANS_2_POW_13 - 1; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt; 3; j++) { for (int k = 0; k &amp;lt; DICE_CASE_CNT; k++) { DicesInfo dicesInfo; convertDiceIntToInfo(k, dicesInfo); calBestActionAndScore(i, j, dicesInfo); int64_t bestActionInt = bestAction[i][j][k]; int idx = i * (3 * DICE_CASE_CNT) + j * DICE_CASE_CNT + k; data[idx] = bestActionInt; } } //printf(&quot;진행률: %.2f%%\\n&quot;, (i + 1) / (float)ANS_2_POW_13 * 100); printCategoryMask(i); time_t t = time(nullptr); tm* now = localtime(&amp;amp;t); cout &amp;lt;&amp;lt; put_time(now, &quot; %Y/%m/%d %H:%M:%S&quot;) &amp;lt;&amp;lt; &#39;\\n&#39;; } outFile.write(reinterpret_cast&amp;lt;const char*&amp;gt;(data), sizeof(data)); outFile.close(); return 0;}3차원 배열인 bestAction을 펼쳐 1차원 배열로 만든 뒤 바이너리 파일에 저장했다. 이 과정을 수행하는 데에도 마찬가지로 5시간 40분이 소요되었다.불러오기void loadBestActionData() { ifstream inFile(&quot;bestAction.bin&quot;, ios::binary); if (!inFile.is_open()) { printf(&quot;bestAction.bin 파일 오픈 실패\\n&quot;); exit(1); } printf(&quot;bestAction.bin 파일 오픈 성공\\n&quot;); static int8_t data[ANS_2_POW_13 * 3 * DICE_CASE_CNT]; inFile.read(reinterpret_cast&amp;lt;char*&amp;gt;(data), sizeof(data)); inFile.close(); for (int i = 0; i &amp;lt; ANS_2_POW_13; i++) { for (int j = 0; j &amp;lt; 3; j++) { for (int k = 0; k &amp;lt; DICE_CASE_CNT; k++) { int idx = i * (3 * DICE_CASE_CNT) + j * DICE_CASE_CNT + k; bestAction[i][j][k] = data[idx]; } } } printf(&quot;데이터 불러오기 완료\\n\\n&quot;); return;}저장된 바이너리 파일을 다시 읽어 1차원 배열에 불러온 후, 이를 3차원 배열에 재배치했다.이제 프로그램이 처음 실행될 때 loadBestActionData()를 한 번 호출하면, bestAction 배열의 모든 원소가 -1이 아닌 유효 상태가 된다. 그 결과, calBestActionAndScore()를 호출했을 때 원하는 값을 즉시 얻을 수 있다.• 후기 •보너스를 완벽히 고려한 로직이 아닌 점은 아쉽지만, 200점대로 꽤 준수한 평균 점수를 내는 로직 구현에 성공한 것에 만족한다. 이 AI를 이용해서 뽑아낸 각종 통계를 그래프로 시각화한 자료를 추후 포스팅하겠다." }, { "title": "[Spready] 착시 연결 기믹을 구현한 방법", "url": "/posts/spready-optical-illusion-gimmick/", "categories": "Development Log", "tags": "Spready", "date": "2024-10-23 00:00:00 +0900", "snippet": " • Spready 스팀 페이지 •• Spready 플레이스토어 •• Spready Demo 플레이스토어 •게임 소개Spready에 대해 간단한 소개부터 하자면, 4개 챕터로 이루어진 색칠하는 3D 퍼즐 게임이다. 각 스테이지에는 캔버스가 배치되어 있다. 플레이어는 크레파스와 지우개를 사용해 모든 캔버스를 색칠하면 된다. 거기에 휘어진 캔버스도 등장한다. 크레파스가 딱딱할 줄 알았겠지만 사실 아니다 2챕터부터는 캔버스를 회전시킬 수 있는 바퀴도 보이기 시작한다. 3챕터부터는 카메라 각도를 잘 맞추면 크레파스나 지우개를 복제할 수 있다.그럼 4챕터엔 뭐가 나올까?이 글에서 설명하려고 하는 착시 연결 기믹이다. 두 캔버스가 실제로 닿아있지 않아도, 카메라 각도를 조절해서 닿아있는 것처럼 보이게 만들면 크레파스가 그 사이를 지나가며 색칠할 수 있게 해주는 기믹이다.별거 아닌 것처럼 보일 수 있지만, 착시 효과를 구현하면서도 이상하게 보이는 부분이 없도록 하기 위해 많은 시행착오를 겪었다. 이 글에서는 실패했던 방법과, 제대로 구현하는 데에 성공한 방법을 소개하려고 한다.실패한 방법 이 기믹을 구현할 때 특별한 처리를 하지 않고 크레파스를 이동시키면 이렇게 보인다.먼 쪽의 캔버스를 지나는 동안은 가까운 쪽의 캔버스에 가려져있다가, 어느 순간 가까운 쪽의 캔버스 위로 올라와있게 된다.하지만 두 캔버스가 평평하게 맞닿아있는 것처럼 보이도록 착시를 일으켜야 하기 때문에, 크레파스가 캔버스에 가려지면 안 된다.여기서 떠올린 아이디어는 레이어를 분리하는 것이다.레이어 분리 방법 나머지 레이어 이동 중인 크레파스 레이어 이동 중인 크레파스 레이어와 나머지 레이어를 분리해서, 이동 중인 크레파스 레이어가 캔버스보다 무조건 앞에 보이게 하면 앞서 설명한 문제가 해결된다.(레이어 이미지에서 검은색인 부분은 실제로는 투명해서 뒷 레이어에 그려진 게 투과되어 보이는 부분이다) 크레파스가 어느 순간 올라온 것처럼 보이는 문제가 해결된 걸 확인할 수 있다. 하지만 가까운 오브젝트가 크레파스를 가리는 경우가 또다른 문제임을 알게 되었다.이 경우, 주황색 크레파스와 위쪽 캔버스는 크레파스를 가리는 위치에 있으므로 크레파스보다 앞에 보여야 한다. 그러나 크레파스 레이어 때문에 이들이 가려지는 문제가 발생한다.이동 중인 크레파스가 모든 오브젝트보다 항상 앞에 보이면 안 되며, 카메라에 더 가까운 오브젝트보다는 뒤에 보여야 한다.레이어 3단 분리 방법 먼 오브젝트 레이어 이동 중인 크레파스 레이어 가까운 오브젝트 레이어 그래서 레이어를 추가했다.크레파스를 가릴만한 위치에 있는 오브젝트를 분류해서 가까운 오브젝트 레이어에 넣어준 뒤, 이동 중인 크레파스 레이어보다 항상 앞에 보이게 해줬다. 잘 작동한다! 앞에서 말한 모든 문제들이 해결됐다.그러나… 문제 사례 1 문제 사례 2하지만 착각이었다. 위와 같은 문제 사례가 계속 발견되었고, 레이어 분리만으로는 해결할 수 없거나 완전히 해결하기 매우 어려운 문제임을 깨달았다.성공한 방법두 캔버스가 실제로는 떨어져 있지만 연결되어 있는 것처럼 크레파스가 지나가야 한다. 이때 가까운 캔버스에서는 크레파스도 가까이에 있고, 먼 캔버스에서는 크레파스도 멀리 있게 하면 앞서 발견된 문제들이 해결된다. 그래서 레이어를 분리하지 않고, 크레파스 자체를 분리하기로 했다. 카메라 각도만 유지된다면 크레파스를 동강내도 한 개의 크레파스처럼 보인다. 착시 연결 상태에서 크레파스가 이동 중일 땐 카메라 시점을 바꿀 수 없기 때문에 동강난 크레파스의 단면을 보게 될 위험은 없다. 또한, 크레파스를 분리함으로써 앞서 언급한 모든 문제가 해결되었다! 문제 해결 1 문제 해결 2" }, { "title": "[백준 4781번] 사탕 가게 [C++]", "url": "/posts/boj-4781/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Dynamic Programming, Knapsack Problem", "date": "2022-08-26 00:00:00 +0900", "snippet": "4781번: 사탕 가게 문제 링크: 4781번: 사탕 가게개요각 테스트케이스마다 사탕 n개의 칼로리와 가격이 주어졌을 때, m만큼의 돈으로 얻을 수 있는 최대 칼로리를 출력하는 문제이다. 0/1 배낭 문제의 형태를 띠고 있지만 각 사탕을 무제한으로 구매할 수 있고, 가격이 정수가 아니라는 점을 고려해야 한다.풀이n과 m 입력받기int n, m; double tmp;scanf(&quot;%d %lf&quot;, &amp;amp;n, &amp;amp;tmp);m = (int)(tmp * 100 + 0.5);이 문제에서 상근이가 가지고 있는 돈의 양 m은 소수점 둘째자리까지 주어지는 실수이다. 그러나 실수로는 dp를 수행하기 어렵기 때문에 100을 곱해 정수로 만들어서 사용했다.int로 강제형변환 하기 전에 0.5를 더해서 값에 영향을 미치지 않되 부동소수 오차로 인해 잘못된 연산 결과가 나오는 경우를 방지했다.사탕 정보 입력받기pair&amp;lt;int, int&amp;gt; arr[MAX_N];for (int i = 0; i &amp;lt; n; i++) { scanf(&quot;%d %lf&quot;, &amp;amp;arr[i].first, &amp;amp;tmp); arr[i].second = (int)(tmp * 100 + 0.5);}pair 배열에 각 사탕의 칼로리와 가격을 입력받았다. 여기서 가격은 위에서의 m과 마찬가지로 100을 곱해 정수로 만들어서 저장했다.dp 수행하기int dp[MAX_M + 1] = { 0 };for (int i = 0; i &amp;lt; n; i++) { for (int j = arr[i].second; j &amp;lt;= m; j++) { dp[j] = max(dp[j], dp[j - arr[i].second] + arr[i].first); }}다이나믹 프로그래밍으로 배낭 문제를 수행할 것이다. dp[a]에는 돈을 a만큼 사용해서 얻을 수 있는 최대 칼로리이다(a는 100을 곱해 정수로 바뀐 상태이다).i가 도는 반복문에서 모든 사탕을 순회하고, 사탕마다 j가 도는 반복문에서 사탕의 가격부터 가지고 있는 돈의 양만큼 순회하며 dp배열의 값을 변경한다. dp[j]의 값을 j보다 현재 사탕의 가격만큼 덜 썼을 때 얻는 최대 칼로리(dp[j - arr[i].second])에 현재 사탕의 칼로리(arr[i].first)를 더한 값으로 갱신하길 반복하며, 최종적으로 우리가 구하고자 하는 dp[m]을 얻는다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 5000#define MAX_M 10000int main() { int n, m; double tmp; scanf(&quot;%d %lf&quot;, &amp;amp;n, &amp;amp;tmp); m = (int)(tmp * 100 + 0.5); while (n != 0 || m != 0) { pair&amp;lt;int, int&amp;gt; arr[MAX_N]; for (int i = 0; i &amp;lt; n; i++) { scanf(&quot;%d %lf&quot;, &amp;amp;arr[i].first, &amp;amp;tmp); arr[i].second = (int)(tmp * 100 + 0.5); } int dp[MAX_M + 1] = { 0 }; for (int i = 0; i &amp;lt; n; i++) { for (int j = arr[i].second; j &amp;lt;= m; j++) { dp[j] = max(dp[j], dp[j - arr[i].second] + arr[i].first); } } printf(&quot;%d\\n&quot;, dp[m]); scanf(&quot;%d %lf&quot;, &amp;amp;n, &amp;amp;tmp); m = (int)(tmp * 100); } return 0;}" }, { "title": "[백준 1395번] 스위치 [C++]", "url": "/posts/boj-1395/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Segment tree, Segment Tree with Lazy Propagation", "date": "2022-08-11 00:00:00 +0900", "snippet": "1395번: 스위치 문제 링크: 1395번: 스위치개요세그먼트 트리를 이용해 쿼리를 수행하고 부분합을 출력하는 문제이다. 그러나 원소의 개수와 쿼리의 개수가 최대 100,000으로, 평범한 세그먼트 트리로 풀이하면 시간 초과를 맞이하는 미래가 찾아온다. 이 문제는 ‘느리게 갱신되는 세그먼트 트리’ 알고리즘을 이용할 것이다.평범한 세그먼트 트리에 대해 잘 모른다면 [백준 14438번] 수열과 쿼리 17 [C++] 포스팅을 읽어보길 바란다.필자는 세그먼트 트리와 같은 크기의 lazy 배열을 이용할 것이다. (구간합을 저장하는 세그먼트 트리의 원소를 pair&amp;lt;int, int&amp;gt;로 바꿔 하나의 배열에 같이 저장해도 상관없다.) 평범한 세그먼트 트리에서는 매 구간 업데이트 쿼리마다 세그먼트 트리의 리프 노드까지 업데이트했다. 그러나 시간을 절약하기 위해 우린 조금 게을러질 필요가 있다. 업데이트 된 정보를 바로바로 자식 노드에게 물려주는 게 아니라 lazy라는 배열에 저장만 해뒀다가, “필요할 때” 업데이트하는 것이다.풀이구간 합 반환 함수int query(int node, int start, int end, int L, int R) { applyLazy(node, start, end); if (end &amp;lt; L || R &amp;lt; start) return 0; if (L &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= R) return segTree[node]; int mid = (start + end) / 2; return query(node * 2, start, mid, L, R) + query(node * 2 + 1, mid + 1, end, L, R);}일반적인 세그먼트 트리의 구간 합 함수와 동일하다. 현재 탐색 구간(start~end)이 목표 구간(L~R)에 전혀 포함되지 않으면 함수 탈출, 완전히 포함돠면 해당 세그먼트 트리의 값 반환, 일부만 겹치만 탐색 구간을 반으로 나눠서 재귀를 통해 탐색하는 과정을 거친다.다른 점이 있다면 맨 처음마다 applyLazy 함수를 호출한다는 것이다.lazy 적용하는 함수void applyLazy(int node, int start, int end) { if (lazy[node] == 0) return; segTree[node] = (end - start + 1) - segTree[node]; if (start != end) { lazy[node * 2] ^= 1; lazy[node * 2 + 1] ^= 1; } lazy[node] = 0; return;}현재 노드에 저장된 lazy값이 있다면(0이 아니라면) 현재 노드의 값을 업데이트하고, 자식 노드에게 lazy를 물려준다. 이후 중복 작업이 일어나지 않게 현재 노드의 lazy를 0으로 초기화해준다. 이 문제의 쿼리는 구간 반전이기 때문에 목적에 맞게 수행해주었다.세그먼트 트리 업데이트 함수void updateSegTree(int node, int start, int end, int L, int R) { applyLazy(node, start, end); if (L &amp;gt; end || R &amp;lt; start) return; if (L &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= R) { segTree[node] = (end - start + 1) - segTree[node]; if (start != end) { lazy[node * 2] ^= 1; lazy[node * 2 + 1] ^= 1; } return; } int mid = (start + end) / 2; updateSegTree(node * 2, start, mid, L, R); updateSegTree(node * 2 + 1, mid + 1, end, L, R); segTree[node] = segTree[node * 2] + segTree[node * 2 + 1]; return;}일반적인 세그먼트 트리 업데이트 함수와 비슷하다. 그러나 구간 합 반환 함수와 마찬가지로 맨 처음마다 applyLazy 함수를 호출해줘야 한다. 또한 탐색 구간이 목표 구간에 환전히 포함됐을 때 현재 노드의 값을 업데이트 것 뿐만 아니라 현재 노드의 자식 노드의 lazy 값을 수정해줘야 한다.전체 코드#include &amp;lt;iostream&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 1000000int n, k;int arr[MAX_N + 1] = { 0 }, segTree[MAX_N * 4] = { 0 }, lazy[MAX_N * 4] = { 0 };int query(int node, int start, int end, int L, int R);void applyLazy(int node, int start, int end);void updateSegTree(int node, int start, int end, int L, int R);int main() { scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;k); for (int t = 0; t &amp;lt; k; t++) { int cmd, a, b; scanf(&quot;%d %d %d&quot;, &amp;amp;cmd, &amp;amp;a, &amp;amp;b); a--, b--; if (cmd == 0) updateSegTree(1, 0, n - 1, a, b); else if (cmd == 1) printf(&quot;%d\\n&quot;, query(1, 0, n - 1, a, b)); } return 0;}int query(int node, int start, int end, int L, int R) { applyLazy(node, start, end); if (end &amp;lt; L || R &amp;lt; start) return 0; if (L &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= R) return segTree[node]; int mid = (start + end) / 2; return query(node * 2, start, mid, L, R) + query(node * 2 + 1, mid + 1, end, L, R);}void applyLazy(int node, int start, int end) { if (lazy[node] == 0) return; segTree[node] = (end - start + 1) - segTree[node]; if (start != end) { lazy[node * 2] ^= 1; lazy[node * 2 + 1] ^= 1; } lazy[node] = 0; return;}void updateSegTree(int node, int start, int end, int L, int R) { applyLazy(node, start, end); if (L &amp;gt; end || R &amp;lt; start) return; if (L &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= R) { segTree[node] = (end - start + 1) - segTree[node]; if (start != end) { lazy[node * 2] ^= 1; lazy[node * 2 + 1] ^= 1; } return; } int mid = (start + end) / 2; updateSegTree(node * 2, start, mid, L, R); updateSegTree(node * 2 + 1, mid + 1, end, L, R); segTree[node] = segTree[node * 2] + segTree[node * 2 + 1]; return;}" }, { "title": "[백준 1017번] 소수 쌍 [C++]", "url": "/posts/boj-1017/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, DFS, Bipartite Matching", "date": "2022-08-04 00:00:00 +0900", "snippet": "1017번: 소수 쌍 문제 링크: 1017번: 소수 쌍개요수의 리스트가 주어지면, 리스트에 있는 모든 수에 대해 두 수를 합해 소수가 되도록 짝을 지어줄 수 있는지 여부(A)를 확인해야 한다. 또한 첫 번째 수와 짝지었을 때 A가 되는 모든 수를 오름차순으로 출력해야 한다.이 문제에서 주어진 리스트는 하나 뿐이지만 두 그룹으로 나누어서 짝을 지어주면 된다. 왜냐하면 서로 다른 두 자연수의 합으로 만들어지는 소수는 모두 홀수이기 때문이다. (가장 작은 케이스: 1 + 2 = 3)따라서 주어지는 수를 홀수와 짝수로 구분해서 저장했다.두 그룹으로 나눈 원소들에게 짝을 지어줄 땐 이분 매칭 알고리즘을 이용하면 된다. 이분 매칭 알고리즘에 대해 이분 매칭(Bipartite Matching)에 잘 나와있다.풀이eratosthenes 함수void eratosthenes(int n) { for (int i = 2; i &amp;lt;= n; i++) { isPrime[i] = 1; } for (int i = 2; i * i &amp;lt;= n; i++) { if (isPrime[i]) { for (int j = i * i; j &amp;lt;= n; j += i) { isPrime[j] = 0; } } }}평범한 에라토스테네스의 체이다. 이에 대해 22. 에라토스테네스의 체에 잘 나와있다. 범위 내의 모든 수를 빠르게 미리 소수 판정을 해서 isPrime 배열에 저장해주는 함수이다.리스트에 들어있는 수는 1000보다 작거나 같은 자연수라고 나와있으므로, 리스트의 두 수를 합했을 때의 최댓값인 2000까지 판정해두면 된다. main함수에서 eratosthenes(2000)을 1회 호출해서 소수 판정을 해두고, 이후 n의 소수 여부를 확인할 때 isPrime[n]를 참조했다.입력받기for (int i = 0; i &amp;lt; n; i++) { int num; scanf(&quot;%d&quot;, &amp;amp;num); if (i == 0) firstNum = num; if ((num + firstNum) % 2 == 0) arr1[cnt1++] = num; else arr2[cnt2++] = num; } if (cnt1 != cnt2) { printf(&quot;-1&quot;); return 0; }개요에서 말한 대로 2로 나눴을 때의 나머지가 첫 번째로 주어지는 수와 같은 수는 arr1에, 다른 수는 arr2에 입력했다. cnt1과 cnt2는 각 배열 원소의 수인데, 모든 수를 입력받은 시점에서 cnt1과 cnt2가 서로 다를 경우 절대로 모든 수에 대해 짝을 지어줄 수 없기 때문에 -1을 출력하고 바로 프로그램을 종료했다.정답 구하기bool vstd[MAX_N] = { false };int pairIdx[MAX_N] = { 0 };int ans[MAX_N], ansIdx = 0; for (int firstPairIdx = 0; firstPairIdx &amp;lt; cnt2; firstPairIdx++) { if (isPrime[arr1[0] + arr2[firstPairIdx]]) { int cnt = 1; for (int toIdx = 0; toIdx &amp;lt; cnt2; toIdx++) pairIdx[toIdx] = -1; pairIdx[firstPairIdx] = 0; vstd[0] = true; for (int fromIdx = 1; fromIdx &amp;lt; cnt1; fromIdx++) { for (int i = 1; i &amp;lt; cnt1; i++) vstd[i] = false; if (dfs(fromIdx)) cnt++; } if (cnt == n / 2) { ans[ansIdx++] = arr2[firstPairIdx]; } } }ans는 우리가 최종 출력할 값인, ‘첫 번째 수와 짝지었을 때 모든 수를 짝지을 수 있게 되는 수’들을 담을 배열이다. 오름차순으로 출력해야 하기 때문에 바로 출력하지 않고 배열에 보관했다가 이후 정렬해서 출력하면 된다.arr2 배열의 모든 원소에 대해 확인하면서(firstPairIdx가 도는 반복문) arr1[0]에 짝을 지어주고, arr1[0]을 제외한 arr1 배열의 모든 원소에 대해(fromIdx가 도는 반복문) dfs()를 호출해 짝을 지어줄 수 있는지 이분 매칭 알고리즘을 확인했다. 지어진 짝의 개수(cnt)가 리스트의 수의 개수의 절반이라면 모든 수가 짝지어진 것이므로 firstPairIdx를 ans 배열에 추가했다.vstd 배열은 arr1의 어떤 원소에 해당하는 인덱스를 이미 방문했는지 표시하는 배열로, 매 dfs()를 호출하기 전마다 false로 초기화했다. 즉 이번 탐색(main에서의 dfs() 호출)에서 이미 지나온 원소로 또 진입하는 걸 막기 위함이다. pairIdx배열은 arr2의 특정 인덱스에 해당하는 원소가 arr1의 어떤 인덱스에 매칭된 원소인지 저장하는 배열이다. arr1[0]에 매칭시킨 원소가 바뀔 때마다-1로 초기화했다.dfs 함수bool vstd[MAX_N] = { false };int pairIdx[MAX_N] = { 0 };int dfs(int fromIdx) { vstd[fromIdx] = true; for (int toIdx = 0; toIdx &amp;lt; cnt2; toIdx++) { if (isPrime[arr1[fromIdx] + arr2[toIdx]]) { if (pairIdx[toIdx] == -1 || !vstd[pairIdx[toIdx]] &amp;amp;&amp;amp; dfs(pairIdx[toIdx])) { pairIdx[toIdx] = fromIdx; return 1; } } } return 0;}fromIdx는 arr1에 해당하는 인덱스이고, toIdx는 arr2에 해당하는 인덱스이다. arr2에 해당하는 인덱스에 해당하는 원소(arr2[toIdx])를 모두 탐색해 해당 인덱스의 원소가 매칭되지 않았거나, arr2[toIdx]의 매칭 상대(pairIdx[toIdx])의 상대를 바꿀 수 있다면 바꾼 뒤 (이 과정에서 재귀 호출이 발생하고, 바꿀 수 있는 경우엔 바뀐 후에 현재 재귀 스택으로 돌아와 다음 작업을 진행하게 된다.) pairIdx에 해당하는 원소에 arr2[toIdx]를 매칭시켜준다.매칭 성공 시 1을 바로 반환하고, arr2의 모든 원소와도 매칭이 불가능할 경우 0을 반환한다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 50#define MAX_NUM 1000bool isPrime[MAX_NUM * 2 + 1] = { 0 };bool vstd[MAX_N] = { false };int pairIdx[MAX_N] = { 0 };int arr1[MAX_N], arr2[MAX_N], cnt1 = 0, cnt2 = 0;void eratosthenes(int n);int dfs(int from);int main() { int n, firstNum; scanf(&quot;%d&quot;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { int num; scanf(&quot;%d&quot;, &amp;amp;num); if (i == 0) firstNum = num; if ((num + firstNum) % 2 == 0) arr1[cnt1++] = num; else arr2[cnt2++] = num; } if (cnt1 != cnt2) { printf(&quot;-1&quot;); return 0; } eratosthenes(MAX_NUM * 2); int ans[MAX_N], ansIdx = 0; for (int firstPairIdx = 0; firstPairIdx &amp;lt; cnt2; firstPairIdx++) { if (isPrime[arr1[0] + arr2[firstPairIdx]]) { int cnt = 1; for (int toIdx = 0; toIdx &amp;lt; cnt2; toIdx++) pairIdx[toIdx] = -1; pairIdx[firstPairIdx] = 0; vstd[0] = true; for (int fromIdx = 1; fromIdx &amp;lt; cnt1; fromIdx++) { for (int i = 1; i &amp;lt; cnt1; i++) vstd[i] = false; if (dfs(fromIdx)) cnt++; } if (cnt == n / 2) { ans[ansIdx++] = arr2[firstPairIdx]; } } } sort(ans, ans + ansIdx); for (int i = 0; i &amp;lt; ansIdx; i++) { printf(&quot;%d &quot;, ans[i]); } if (ansIdx == 0) printf(&quot;-1&quot;); return 0;}void eratosthenes(int n) { for (int i = 2; i &amp;lt;= n; i++) { isPrime[i] = 1; } for (int i = 2; i * i &amp;lt;= n; i++) { if (isPrime[i]) { for (int j = i * i; j &amp;lt;= n; j += i) { isPrime[j] = 0; } } }}int dfs(int fromIdx) { vstd[fromIdx] = true; for (int toIdx = 0; toIdx &amp;lt; cnt2; toIdx++) { if (isPrime[arr1[fromIdx] + arr2[toIdx]]) { if (pairIdx[toIdx] == -1 || !vstd[pairIdx[toIdx]] &amp;amp;&amp;amp; dfs(pairIdx[toIdx])) { pairIdx[toIdx] = fromIdx; return 1; } } } return 0;}" }, { "title": "[백준 16916번] 부분 문자열 [C++]", "url": "/posts/boj-16916/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, String, KMP", "date": "2022-06-30 00:00:00 +0900", "snippet": "16916번: 부분 문자열 문제 링크: 16916번: 부분 문자열개요문자열이 두 개 주어지면, 두 번째 문자열이 첫 번째 문자열의 부분 문자열인지만 판단하면 되는 간단해 보이는 문제이다. 쉽게 떠오르는 방법인 브루트 포스로 풀면 문자열 길이가 n일 때 시간복잡도가 O(n^2)이 되는데, n이 최대 100만이므로 시간 초과를 피할 수 없다.이 때 필요한 게 KMP 알고리즘이다. KMP 알고리즘에 대해 KMP : 문자열 검색 알고리즘에 잘 나와있다.백준에서 KMP 알고리즘을 사용해야 하는 문제는 대부분 골드3 이상에 배정되고 있지만, 이 문제의 경우 파이썬의 in 키워드와 c/cpp의 strstr 함수를 이용해 쉽게 풀리기 때문에 브론즈와 골드로 난이도 기여가 갈려서, 애매한 실버1에 배정된 상태이다.이 글에서는 strstr 함수를 이용하지 않고 KMP 알고리즘을 이용하여 풀이하겠다.풀이makePi 함수void makePi() { int j = 0; for (int i = 1; i &amp;lt; len2; i++) { while (j &amp;gt; 0 &amp;amp;&amp;amp; str2[i] != str2[j]) j = pi[j - 1]; if (str2[i] == str2[j]) pi[i] = ++j; }}이 함수는 str2만 이용해서 pi 배열을 채우는 작업을 해준다. pi[i]는 str[0 ~ i]에 대해 가장 긴 접두사이자 접미사인 문자열의 길이이다.i는 접미사의 마지막 인덱스(현재 취급하는 문자열의 마지막 인덱스), j는 접두사의 마지막 인덱스가 되도록 유지하는 것이 핵심이다.while문에 도착했을 때, str2[0 ~ j-1]은 str2[0 ~ i-1]에 대해 접두사이자 접미사임을 유지하고 있는 상태이다. 이 때 str2[i] == str2[j]인 경우, str2[0 ~ j]은 str2[0 ~ i]에 대해 접두사이자 접미사이기 때문에 pi[i]는 j+1(j가 0부터 시작하는 인덱스이기 때문에 길이는 그 문자까지의 길이는 j+1이 된다)이며, 다음 탐색을 위해 j를 1 증가시킨다.str2[i] != str2[j]인 경우, 접두사이자 접미사일 가능성이 있는 곳까지 j를 감소시켜야 한다. pi[j - 1]은 str2 길이가 j인 부분 문자열의 접두사이자 접미사인 문자열의 길이이므로, j를 pi[j - 1]로 변화시키면 여전히 str2[0 ~ j-1]은 str2[0 ~ i-1]에 대해 접두사이자 접미사이다. 따라서 while문을 반복하여 j가 0이 되거나 우리가 원하는 j를 찾으면 탈출하게 된다.kmp 함수void kmp() { int j = 0; for (int i = 0; i &amp;lt; len1 &amp;amp;&amp;amp; !isSubStr; i++) { while (str1[i] != str2[j] &amp;amp;&amp;amp; j &amp;gt; 0) j = pi[j - 1]; if (str1[i] == str2[j]) j++; if (j == len2) isSubStr = 1;; }}이 함수를 이용하면 str2가 str1의 부분 문자열로 나타나는 부분을 전부 찾을 수 있다. 그러나 우리는 부분 문자열 여부만 판단하면 되기 때문에 처음 부분 문자열이 나타나는 곳을 찾으면 isSubStr을 1로 바꾸고 탐색을 중단할 것이다.i는 str1에서 현재 여기까지 탐색했다는 것을 나타내며, for문을 돌며 일정하게 증가한다. j는 str2에서 현재 여기까지 일치했다는 것을 나타낸다.while문을 만났을 때, str2[0 ~ j-1]과 str1[i-j ~ i-1]은 일치한 상태이다.이 때 str1[i] == str2[j]인 경우, str2[0 ~ j]과 str1[i-j ~ i]이 일치한 상태인 게 확인된 것이며, 이 때 j를 1 증가시켜준다. 그 이후 j가 str2의 길이인 len2와 같다면 str1의 어느 부분과 str2이 전부 일치한 것이 확인됐으므로 isSubStr을 1로 바꿔준다.str1[i] != str2[j]인 경우, str2[0 ~ j-1]과 str1[i-j ~ i-1]는 일치했지만 더이상 일치하지 않는다는 의미이므로 str1에서 str2이 일치하기 시작한 위치를 바꿔줘야 한다(j를 바꿔줘야 한다). 우리는 pi 배열을 미리 구해놨기 때문에, 현재 j보다 작으면서 str2[0 ~ j]과 str1[i-j ~ i]가 일치하는 j의 최댓값이 pi[j-1]임을 알 수 있다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_LEN 1000000char str1[MAX_LEN + 1], str2[MAX_LEN + 1];int pi[MAX_LEN + 1] = { 0 }, len1, len2, isSubStr = 0;void makePi();void kmp();int main() { scanf(&quot;%s&quot;, str1); scanf(&quot;%s&quot;, str2); len1 = strlen(str1); len2 = strlen(str2); makePi(); kmp(); printf(&quot;%d&quot;, isSubStr); return 0;}void makePi() { int j = 0; for (int i = 1; i &amp;lt; len2; i++) { while (j &amp;gt; 0 &amp;amp;&amp;amp; str2[i] != str2[j]) j = pi[j - 1]; if (str2[i] == str2[j]) pi[i] = ++j; }}void kmp() { int j = 0; for (int i = 0; i &amp;lt; len1 &amp;amp;&amp;amp; !isSubStr; i++) { while (str1[i] != str2[j] &amp;amp;&amp;amp; j &amp;gt; 0) j = pi[j - 1]; if (str1[i] == str2[j]) j++; if (j == len2) isSubStr = 1;; }}" }, { "title": "[백준 2696번] 중앙값 구하기 [C++]", "url": "/posts/boj-2696/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Priority queue", "date": "2022-02-27 00:00:00 +0900", "snippet": "2696번: 중앙값 구하기 문제 링크: 2696번: 중앙값 구하기개요문제가 시킨 일인 수열이 주어지면 홀수 번째 수를 읽을 때마다 중앙값을 출력하는 작업만 착실하게 수행하면 되는 문제이다. 하지만 매번 수열을 정렬하고 중간 인덱스 값을 출력하는 방식으로는 시간초과를 피할 수 없다. 따라서 우선순위 큐를 두 개 이용해서 풀이할 것이다.maxPq와 minPq를 이용할 것이다. maxPq에선 값이 큰 수가 높은 우선순위를, minPq에선 값이 작은 수가 높은 우선순위를 갖게 했다. maxPq엔 중앙값과 중앙값보다 작은 수들이, minPq에는 중앙값보다 큰 수들이 존재하도록 유지할 것이다. (중앙값이 중복일 경우 minPq에 중앙값과 같은 수가 존재할 수도 있다.)풀이우선순위 큐에 수 입력if (maxPq.size() == minPq.size()) { //홀수 번째 입력할 차례 if (maxPq.empty() || minPq.top() &amp;gt;= num) { maxPq.push(num); } else { maxPq.push(minPq.top()); minPq.pop(); minPq.push(num); }}else { //짝수 번째 입력할 차례 if (maxPq.top() &amp;gt; num) { minPq.push(maxPq.top()); maxPq.pop(); maxPq.push(num); } else { minPq.push(num); }}우선 maxPq와 minPq에 있는 수들의 개수 동일 여부를 이용해서 분기를 나누었다. maxPq.size() == minPq.size()인 경우엔 총 숫자가 짝수개 존재하므로 홀수 번째 수를 입력할 차례이고, 그렇지 않다면 짝수 번째 수를 입력할 차례이다.1. 홀수 번째 입력할 차례이번 수가 minPq.top()보다 작거나 같은 경우엔 고민없이 maxPq에 push해주면 된다.조건에 minPq.top() 대신 maxPq.top()을 사용하면 이번 수가 중앙값이 될 경우가 반례가 된다.이번 수가 minPq.top()보다 큰 경우엔 조금 귀찮다. 이번 수가 입력된 후에는 maxPq의 크기가 minPq보다 딱 1 큰 상태로 유지되게 해야 하므로 우선 minPq.top()을 maxPq로 이동시켜준 후, 이번 수를 minPq에 push해줘야 한다.2. 짝수 번째 입력할 차례이번 수가 maxPq.top()보다 작은 경우엔 또다시 귀찮다. 이번 수가 입력된 후에는 maxPq의 크기와 minPq의 크기가 같도록 유지시켜줘야 하므로 우선 maxPq.top()을 minPq로 이동시켜준 후, 이번 수를 maxPq에 push해줘야 한다.그렇지 않은 경우엔 그냥 minPq에 push해주면 된다.중앙값 저장if (i % 2 == 0) { mid[midIdx++] = maxPq.top();}홀수 번째 수를 입력받으면 우선순위 큐에 저장한 뒤에 별도 배열에 중앙값(maxPq.top())을 순서대로 저장해준다. 이후 입력이 종료되면 순서대로 출력해주면 된다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_M 9999int main() { int t; scanf(&quot;%d&quot;, &amp;amp;t); while (t--) { priority_queue&amp;lt;int&amp;gt; maxPq; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; minPq; int n, mid[MAX_M], midIdx = 0; scanf(&quot;%d&quot;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { int num; scanf(&quot;%d&quot;, &amp;amp;num); if (maxPq.size() == minPq.size()) { //홀수 번째 입력할 차례 if (maxPq.empty() || minPq.top() &amp;gt;= num) { maxPq.push(num); } else { maxPq.push(minPq.top()); minPq.pop(); minPq.push(num); } } else { //짝수 번째 입력할 차례 if (maxPq.top() &amp;gt; num) { minPq.push(maxPq.top()); maxPq.pop(); maxPq.push(num); } else { minPq.push(num); } } if (i % 2 == 0) { mid[midIdx++] = maxPq.top(); } } printf(&quot;%d&quot;, midIdx); for (int i = 0; i &amp;lt; midIdx; i++) { if (i % 10 == 0) printf(&quot;\\n&quot;); printf(&quot;%d &quot;, mid[i]); } printf(&quot;\\n&quot;); } return 0;}" }, { "title": "[백준 14621번] 나만 안되는 연애 [C++]", "url": "/posts/boj-14621/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Graph, Minimum Spanning Tree", "date": "2022-02-19 00:00:00 +0900", "snippet": "14621번: 나만 안되는 연애 문제 링크: 14621번: 나만 안되는 연애개요주어진 그래프에서 노드들을 연결하는 최단 거리 트리의 총 거리를 구하는 문제이다. 최소 스패닝 트리 알고리즘 중 크루스칼 알고리즘을 이용해 풀이하겠다.최소 스패닝 트리에 대해 [알고리즘] 최소 신장 트리(MST, Minimum Spanning Tree)란 포스팅을 참고하면 좋겠다.풀이getRoot 함수int getRoot(int num) { if (num != prnt[num]) { prnt[num] = getRoot(prnt[num]); } return prnt[num];}학교 a와 b가 있을 때, prnt[a]가 b인 경우엔 a와 b가 직접 연결되어 있는 경우이고, getRoot(a)와 getRoot(b)가 같은 경우엔 두 대학은 연결된 경로가 있는 경우이다. 두 경우는 동시에 발생할 수 있다. 매번 부모(직접 연결된 노드) 타고 올라가며 루트 노드를 확인하여 비교하면 시간이 오래 걸리기 때문에 어떤 노드의 루트 노드를 얻음과 동시에 해당 노드부터 루트 노드까지 존재하는 모든 노드(n)의 prnt[n]을 루트 노드로 갱신시켜주어 이후 탐색 시에 시간을 단축시키는 역할이다. 루트 노드(부모가 자기 자신인 노드)에 도달할 때까지 재귀를 반복하고, 자식 노드를 루트 노드로 갱신해준 후 반환한다.경로 길이 계산 이전 int n, m, cnt = 0, sumWeight = 0; scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); getchar(); for (int i = 1; i &amp;lt;= n; i++) { prnt[i] = i; char c; scanf(&quot;%c&quot;, &amp;amp;c); getchar(); if (c == &#39;W&#39;) gender[i] = 1; } for (int i = 0; i &amp;lt; m; i++) { int u, v, w; scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w); tree[i].node1 = u, tree[i].node2 = v; tree[i].weight = w; } qsort(tree, m, sizeof(Edge), compare);대학의 인덱스는 1부터 n까지의 정수이며, 대학 하나를 노드 하나로 취급할 것이다.초기 상태에서 모든 대학은 연결되어 있기 않기 때문에 모든 노드의 부모를 자기 자신의 번호로 초기화 시켜준다.또한 남초 대학교와 여초 대학교가 구분되어 있기 때문에 gender 배열의 해당 대학 인덱스에 남초 대학이면 0, 여초 대학이면 1이 들어가있도록 해준다. 이후 구조체로 만들어둔 간선 배열에 간선을 입력받고, 도로의 거리에 대해 오름차순으로 정렬한다.경로 길이 계산 for (int i = 0; i &amp;lt; m &amp;amp;&amp;amp; cnt &amp;lt; n; i++) { int node1 = tree[i].node1; int node2 = tree[i].node2; int rootNode1 = getRoot(node1); int rootNode2 = getRoot(node2); if (rootNode1 != rootNode2 &amp;amp;&amp;amp; gender[node1] != gender[node2]) { sumWeight += tree[i].weight; prnt[node1] = rootNode1; prnt[rootNode2] = rootNode1; cnt++; } } if (cnt &amp;lt; n - 1) printf(&quot;-1&quot;); else printf(&quot;%d&quot;, sumWeight);정렬된 간선을 순서대로 탐색하며 해당 간선이 연결하는 두 대학이 둘 다 남초거나 둘 다 여초인 경우(gender 배열 값이 같은 경우), 그리고 이미 연결된 대학(조상 노드가 같은 경우)인 경우는 건너뛴다.그렇지 않은 경우는 두 대학을 같은 그룹으로 만들고, 누적 거리에 해당 간선 거리를 더한다. n개 대학을 전부 연결하기 위해서는 최소 (n-1)개의 간선이 필요하다. 간선 배열을 전부 탐색한 이후 시점에서 연결된 간선의 수(cnt)가 n-1보다 작은 경우, 연결되지 않은 대학이 존재한다는 뜻이므로 -1을 출력하고 그렇지 않은 경우엔 누적 거리(sumWeight)를 출력하면 된다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 1000#define MAX_M 10000typedef struct { int node1, node2, weight;} Edge;Edge tree[MAX_M];int prnt[MAX_N + 1];int gender[MAX_N + 1] = { 0 };int compare(const void *a, const void *b);int getRoot(int num);int main() { int n, m, cnt = 0, sumWeight = 0; scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); getchar(); for (int i = 1; i &amp;lt;= n; i++) { prnt[i] = i; char c; scanf(&quot;%c&quot;, &amp;amp;c); getchar(); if (c == &#39;W&#39;) gender[i] = 1; } for (int i = 0; i &amp;lt; m; i++) { int u, v, w; scanf(&quot;%d %d %d&quot;, &amp;amp;u, &amp;amp;v, &amp;amp;w); tree[i].node1 = u, tree[i].node2 = v; tree[i].weight = w; } qsort(tree, m, sizeof(Edge), compare); for (int i = 0; i &amp;lt; m &amp;amp;&amp;amp; cnt &amp;lt; n; i++) { int node1 = tree[i].node1; int node2 = tree[i].node2; int rootNode1 = getRoot(node1); int rootNode2 = getRoot(node2); if (rootNode1 != rootNode2 &amp;amp;&amp;amp; gender[node1] != gender[node2]) { sumWeight += tree[i].weight; prnt[node1] = rootNode1; prnt[rootNode2] = rootNode1; cnt++; } } if (cnt &amp;lt; n - 1) printf(&quot;-1&quot;); else printf(&quot;%d&quot;, sumWeight); return 0;}int compare(const void *a, const void *b) { int x = (*(Edge *)a).weight; int y = (*(Edge *)b).weight; if (x &amp;gt; y) return 1; else if (x &amp;lt; y) return -1; return 0;}int getRoot(int num) { if (num != prnt[num]) { prnt[num] = getRoot(prnt[num]); } return prnt[num];}" }, { "title": "[백준 17387번] 선분 교차 2 [C++]", "url": "/posts/boj-17387/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Geometry, CCW", "date": "2022-02-12 00:00:00 +0900", "snippet": "17387번: 선분 교차 2 문제 링크: 17387번: 선분 교차 2개요두 선분의 양 끝 점이 주어지면 교차 여부를 출력하는 문제이다. ccw 알고리즘을 이용해 두 점이 만드는 선분에 대해 다른 한 점이 어느 방향에 위치하고 있는지를 알아낼 수 있고, 이를 이용해 교차 여부를 확인할 것이다.풀이ccw 함수int ccw(int ax, int ay, int bx, int by, int cx, int cy) { ll ans = ((ll)bx - ax) * ((ll)cy - ay) - ((ll)cx - ax) * ((ll)by - ay); if (ans &amp;gt; 0) return 1; if (ans &amp;lt; 0) return -1; return 0;}ccw 알고리즘에 대해 [알고리즘] CCW로 세 점의 방향성 판별하기 에 잘 나와있다. ccw 함수는 점 a, b, c의 x좌표와 y좌표를 입력받아, 점 a에서 점 b방향으로 향하는 직선에 대해 점 c가 왼쪽에 있으면 1, 오른쪽에 있으면 -1, 직선상에 있으면 0을 반환한다.main 함수int main() { pair&amp;lt;int, int&amp;gt; a, b, c, d; scanf(&quot;%d %d %d %d&quot;, &amp;amp;a.first, &amp;amp;a.second, &amp;amp;b.first, &amp;amp;b.second); scanf(&quot;%d %d %d %d&quot;, &amp;amp;c.first, &amp;amp;c.second, &amp;amp;d.first, &amp;amp;d.second); int ccw1 = ccw(a.first, a.second, b.first, b.second, c.first, c.second); int ccw2 = ccw(a.first, a.second, b.first, b.second, d.first, d.second); int ccw3 = ccw(c.first, c.second, d.first, d.second, a.first, a.second); int ccw4 = ccw(c.first, c.second, d.first, d.second, b.first, b.second); //printf(&quot;%d %d %d %d\\n&quot;, ccw1, ccw2, ccw3, ccw4); //1. 어느 세 점도 일직선상에 놓여있지 않고 두 선분이 교차하는 경우 if (ccw1 * ccw2 &amp;lt; 0 &amp;amp;&amp;amp; ccw3 * ccw4 &amp;lt; 0) { printf(&quot;1&quot;); } //2. 두 선분이 한 직선 위에 놓인 경우 else if (ccw1 == 0 &amp;amp;&amp;amp; ccw2 == 0) { if (a &amp;gt; b) swap(a, b); if (c &amp;gt; d) swap(c, d); //2-1. 두 선분이 겹치는 경우 (2-1) if (a &amp;lt;= d &amp;amp;&amp;amp; c &amp;lt;= b) printf(&quot;1&quot;); //2-2. 두 선분이 겹치지 않는 경우 (2-2) else printf(&quot;0&quot;); } //3. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 경우 (3) else if (ccw1 * ccw2 == 0 &amp;amp;&amp;amp; ccw3 * ccw4 &amp;lt;= 0 || ccw1 * ccw2 &amp;lt;= 0 &amp;amp;&amp;amp; ccw3 * ccw4 == 0) { printf(&quot;1&quot;); } else printf(&quot;0&quot;); return 0;}1. 어느 세 점도 일직선상에 놓여있지 않고 두 선분이 교차하는 경우점 a와 b가 이루는 직선에 대해 점 c와 점 d가 서로 다른 방향에 놓여있고(ccw1 * ccw2 &amp;lt; 0), 점 c와 점 c가 이루는 직선에 대해 점 a와 점 b가 서로 다른 방향에 놓여있는(ccw3 * ccw4 &amp;lt; 0) 경우에는 명백하게 두 선분이 교차함을 알 수 있다.2. 두 선분이 한 직선 위에 놓인 경우점 a와 b가 이루는 직선상에 점 c가 놓여있는(ccw1 == 0) 동시에 점 d도 놓여있는 경우(ccw2 == 0)는 두 선분이 한 직선 위에 놓인 경우임을 알 수 있다. 이 경우에는 점의 위치관계를 이용해서 겹치는지 확인하여 출력하면 된다.3. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 경우 (3)점 a와 b가 이루는 직선상에 점 c나 점 d가 놓여있고(ccw1 * ccw2 == 0), c와 점 c가 이루는 직선에 대해 점 a와 점 b가 서로 다른 방향에 놓여있는(ccw3 * ccw4 &amp;lt; 0) 경우나, 그 반대 경우에는 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 경우이다. 한 점이 직선 위에 놓여있더라도 선분 밖에 있을 수 있기 때문에 이러한 방식으로 체크해주었다.전체 코드#include &amp;lt;iostream&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define ll long longint ccw(int ax, int ay, int bx, int by, int cx, int cy) { ll ans = ((ll)bx - ax) * ((ll)cy - ay) - ((ll)cx - ax) * ((ll)by - ay); if (ans &amp;gt; 0) return 1; if (ans &amp;lt; 0) return -1; return 0;}int main() { pair&amp;lt;int, int&amp;gt; a, b, c, d; scanf(&quot;%d %d %d %d&quot;, &amp;amp;a.first, &amp;amp;a.second, &amp;amp;b.first, &amp;amp;b.second); scanf(&quot;%d %d %d %d&quot;, &amp;amp;c.first, &amp;amp;c.second, &amp;amp;d.first, &amp;amp;d.second); int ccw1 = ccw(a.first, a.second, b.first, b.second, c.first, c.second); int ccw2 = ccw(a.first, a.second, b.first, b.second, d.first, d.second); int ccw3 = ccw(c.first, c.second, d.first, d.second, a.first, a.second); int ccw4 = ccw(c.first, c.second, d.first, d.second, b.first, b.second); //printf(&quot;%d %d %d %d\\n&quot;, ccw1, ccw2, ccw3, ccw4); //어느 세 점도 일직선상에 놓여있지 않고 두 선분이 교차하는 경우 if (ccw1 * ccw2 &amp;lt; 0 &amp;amp;&amp;amp; ccw3 * ccw4 &amp;lt; 0) { printf(&quot;1&quot;); } //두 선분이 한 직선 위에 놓인 경우 else if (ccw1 == 0 &amp;amp;&amp;amp; ccw2 == 0) { if (a &amp;gt; b) swap(a, b); if (c &amp;gt; d) swap(c, d); //두 선분이 겹치는 경우 if (a &amp;lt;= d &amp;amp;&amp;amp; c &amp;lt;= b) printf(&quot;1&quot;); //두 선분이 겹치지 않는 경우 else printf(&quot;0&quot;); } //한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 경우 else if (ccw1 * ccw2 == 0 &amp;amp;&amp;amp; ccw3 * ccw4 &amp;lt;= 0 || ccw1 * ccw2 &amp;lt;= 0 &amp;amp;&amp;amp; ccw3 * ccw4 == 0) { printf(&quot;1&quot;); } else printf(&quot;0&quot;); return 0;}" }, { "title": "[백준 3109번] 빵집 [C++]", "url": "/posts/boj-3109/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Graph, Greedy, DFS", "date": "2022-02-06 00:00:00 +0900", "snippet": "3109번: 빵집 문제 링크: 3109번: 빵집개요n*m 크기의 맵이 주어지면 왼쪽부터 오른쪽까지 연결하는 파이프라인을 겹치지 않게 설치할 수 있는 최대 개수를 구하는 문제이다. 최대한 많은 파이프라인을 만들어야 하기 때문에 왼쪽 가장 위 칸에서부터 시작하며, 오른쪽으로 파이프를 연결할 때는 위, 중간, 아래 순으로 진행한다.풀이main 함수int main() { scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); getchar(); for (int i = 0; i &amp;lt; n; i++) { scanf(&quot;%s&quot;, map[i]); getchar(); } int ans = 0; for (int i = 0; i &amp;lt; n; i++) { ans += dfs(i, 0); } printf(&quot;%d&quot;, ans); return 0;}ans는 출력할 파이프라인의 수로, for문을 돌며 값을 누적해 나갈 것이다. dfs(n, m)은 (n, m) 위치에서 파이프를 연결해 오른쪽 끝에 도달할 수 있으면 1, 없으면 0을 반환한다. 가장 왼쪽 칸을 위에서부터 순서대로 탐색하며, 현재 상태에서 오른쪽 끝까지 도달할 수 있는지 여부를 dfs 함수를 이용해 확인하고 그 값을 ans에 누적하여 출력한다.dfs 함수int dfs(int x0, int y0) { vstd[x0][y0] = 1; if (y0 == m - 1) return 1; for (int d = 0; d &amp;lt; 3; d++) { int x = x0 + dx[d]; int y = y0 + 1; if (0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; m) { if (!vstd[x][y] &amp;amp;&amp;amp; map[x][y] == &#39;.&#39;) { if (dfs(x, y) == 1) return 1; } } } return 0;}이미 방문한(파이프가 놓여있는) 곳에 또 파이프를 놓지 않기 위해 vstd 배열을 이용했다. 현재 위치에서 오른쪽 위, 중간, 아래 순으로 탐색을 진행하며, 더 이상 오른쪽으로 갈 수 없으면 0을, 가장 오른쪽 칸에 도달하면 1을 반환한다.전체 코드#include &amp;lt;iostream&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 10000#define MAX_M 500int n, m;char map[MAX_N][MAX_M+1], vstd[MAX_N][MAX_M] = { 0 };const int dx[3] = { -1, 0, 1 };int dfs(int x0, int y0);int main() { scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); getchar(); for (int i = 0; i &amp;lt; n; i++) { scanf(&quot;%s&quot;, map[i]); getchar(); } int ans = 0; for (int i = 0; i &amp;lt; n; i++) { ans += dfs(i, 0); } printf(&quot;%d&quot;, ans); return 0;}int dfs(int x0, int y0) { vstd[x0][y0] = 1; if (y0 == m - 1) return 1; for (int d = 0; d &amp;lt; 3; d++) { int x = x0 + dx[d]; int y = y0 + 1; if (0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; m) { if (!vstd[x][y] &amp;amp;&amp;amp; map[x][y] == &#39;.&#39;) { if (dfs(x, y) == 1) return 1; } } } return 0;}" }, { "title": "[백준 1517번] 버블 소트 [C++]", "url": "/posts/boj-1517/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Sort, Segment tree, Divide and Conquer", "date": "2022-01-28 00:00:00 +0900", "snippet": "1517번: 버블 소트 문제 링크: 1517번: 버블 소트개요주어진 수열에 대해 버블 소트를 수행하여 오름차순으로 정렬할 때 발생하는 Swap의 횟수, 즉 각 원소의 자리 변화의 총 횟수를 구하는 문제이다. n의 범위가 (1 ≤ n ≤ 500,000)이기 대문에 정직하게 버블 소트를 진행하며 Swap의 횟수를 세면 시간복잡도가 O(n^2)으로, 시간 초과의 늪에서 헤어나올 수 없다. 합병 정렬을 응용해서 시간 내에 풀 수 있다.풀이merge 함수void merge(int left, int mid, int right) { int tmpIdx = left; int i = left, j = mid + 1, cnt = 0; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { //양쪽 다 원소 1개 이상 남아있음 if (arr[i] &amp;lt;= arr[j]) { //왼쪽 원소가 더 작을 때 tmp[tmpIdx++] = arr[i++]; ans += (long long)cnt; //교차점만큼 더하기 } else { //오른쪽 원소가 더 작을 때 tmp[tmpIdx++] = arr[j++]; cnt++; } } if (i &amp;gt; mid) { //왼쪽 원소 소진 완료된 상태일 때 while (j &amp;lt;= right) { tmp[tmpIdx++] = arr[j++]; } } else if (j &amp;gt; right) { //오른쪽 원소 소진 완료된 상태일 때 while (i &amp;lt;= mid) { tmp[tmpIdx++] = arr[i++]; ans += (long long)cnt; //교차점만큼 더하기 } } for (int i = left; i &amp;lt;= right; i++) { arr[i] = tmp[i]; } return;}mid를 기준으로 mid 포함 왼쪽과 오른쪽 배열이 각각 정렬되어 있다는 가정 하에 두 배열을 합친 큰 배열을 만드는 함수이다. 임시 배열에 합쳐진 배열을 만들어둔 후, 합병이 완료되면 원래 배열에 임시 배열을 복사할 것이다.왼쪽 배열과 오른쪽 배열에 원소가 각각 1개 이상 남아있는 동안 반복문을 돌리며 왼쪽 배열의 가장 작은 원소와 오른쪽 배열의 가장 작은 원소를 비교하여 더 작은 원소를 임시 배열의 맨 뒤에 추가하는 작업을 반복한다. 그 후 어느 한 쪽 배열의 원소가 모두 소진된 후엔 남은 원소들을 임시 배열의 뒤에 그대로 추가해준다. 이 때, 우리는 이 문제의 답을 구하기 위해 정렬 전후에서 원소를 이은 선들의 교차점의 수를 구할 것이다.오른쪽 배열의 원소를 임시 배열에 추가할 때는 cnt에 1을 더해주고, 왼쪽 배열의 원소를 임시 배열에 추가할 때는 총 교차 횟수를 저장하는 ans에 cnt를 더해준다. 오른쪽 배열의 원소가 왼쪽 배열의 특정 원소보다 작을 경우, 그러한 원소의 수 만큼 교차점이 생길 수밖에 없기 때문이다.mergeSort 함수void mergeSort(int left, int right) { if (left &amp;lt; right) { int mid = (left + right) / 2; mergeSort(left, mid); mergeSort(mid + 1, right); merge(left, mid, right); } return;}전체를 합병 정렬하는 함수이다. main 함수에서는 이 함수를 mergeSort(0, n - 1)의 형태로 1회 호출할 것이고, 재귀를 통해 더 작은 부분으로 내려갔다가 합쳐지면서 합병 정렬이 종료될 것이다. 현재 범위를 반으로 나눠 왼쪽과 오른쪽을 각각 합병 정렬한 후, 정렬된 양쪽 배열을 합병하면 된다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 500000int n, arr[MAX_N], tmp[MAX_N];long long ans = 0;void mergeSort(int left, int right);void merge(int left, int mid, int right);int main() { scanf(&quot;%d&quot;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { scanf(&quot;%d&quot;, &amp;amp;arr[i]); } mergeSort(0, n - 1); printf(&quot;%lld&quot;, ans); return 0;}//합병 정렬void mergeSort(int left, int right) { if (left &amp;lt; right) { int mid = (left + right) / 2; mergeSort(left, mid); mergeSort(mid + 1, right); merge(left, mid, right); } return;}//양쪽 합병하기void merge(int left, int mid, int right) { int tmpIdx = left; int i = left, j = mid + 1, cnt = 0; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { //양쪽 다 원소 1개 이상 남아있음 if (arr[i] &amp;lt;= arr[j]) { //왼쪽 원소가 더 작을 때 tmp[tmpIdx++] = arr[i++]; ans += (long long)cnt; //교차점만큼 더하기 } else { //오른쪽 원소가 더 작을 때 tmp[tmpIdx++] = arr[j++]; cnt++; } } if (i &amp;gt; mid) { //왼쪽 원소 소진 완료된 상태일 때 while (j &amp;lt;= right) { tmp[tmpIdx++] = arr[j++]; } } else if (j &amp;gt; right) { //오른쪽 원소 소진 완료된 상태일 때 while (i &amp;lt;= mid) { tmp[tmpIdx++] = arr[i++]; ans += (long long)cnt; //교차점만큼 더하기 } } for (int i = left; i &amp;lt;= right; i++) { arr[i] = tmp[i]; } return;}" }, { "title": "[백준 13537번] 수열과 쿼리 1 [C++]", "url": "/posts/boj-13537/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Segment tree, Merge sort tree", "date": "2022-01-21 00:00:00 +0900", "snippet": "13537번: 수열과 쿼리 1 문제 링크: 13537번: 수열과 쿼리 1개요배열 크기 n과 쿼리의 수 m이 최대 100,000이므로 각 구간에서 k보다 큰 값을 찾을 때마다 구간을 전부 탐색하면 시간복잡도가 O(n×m)이 되어 시간 초과와 맞닥뜨리게 될 것이다.세그먼트 트리의 각 노드에 자신과 자식 노드의 모든 원소를 정렬한 vector를 저장해서 풀 수 있다. 세그먼트 트리에 대해 잘 모른다면 아래 문제 풀이를 먼저 읽어보자. [백준 14438번] 수열과 쿼리 17 [C++]풀이아래 설명할 두 함수는 node, start, end라는 인자를 갖고 있다. node는 세그먼트 트리상에서 현재 노드의 인덱스이며, start와 end는 arr 배열 상에서의 현재 탐색 범위의 양 끝 인덱스이다. 두 함수는 재귀의 형태를 가지는데, 위에서 말한 세 인자는 재귀를 거치며 segTree[node]가 arr[start]부터 arr[end]까지의 범위를 담당하는 노드임이 유지되도록 변화한다.세그먼트 트리 생성 함수// 정렬된 자식노드 vector 세그먼트 트리 만들기vector&amp;lt;int&amp;gt; makeSegTree(int node, int start, int end) { if (start == end) { segTree[node].push_back(arr[start]); return segTree[node]; } int mid = (start + end) / 2; vector&amp;lt;int&amp;gt; leftRst = makeSegTree(node * 2, start, mid); vector&amp;lt;int&amp;gt; rightRst = makeSegTree(node * 2 + 1, mid + 1, end); segTree[node] = leftRst; segTree[node].insert(segTree[node].end(), rightRst.begin(), rightRst.end()); sort(segTree[node].begin(), segTree[node].end()); return segTree[node];}보통 세그먼트 트리와는 다르게, 이 문제에서는 세그먼트 트리의 원소의 자료형이 정수 하나가 아니라 vector이다. main 함수에서 이 함수를 makeSegTree(1, 1, n)의 형태로 호출할 것이다. 세그먼트 트리의 루트 노드(1, 전체 범위 담당)부터 시작하여 재귀의 형태로 자식 노드로 뻗어 내려가고, 자식 노드의 값을 이용해 부모 노드의 값을 생성하는 방식이다. 초기 상태의 세그먼트 트리의 모든 노드(vector)는 비어있다.start == end인 경우, 리프 노드에 도달했다는 뜻이므로 현재 세그먼트 트리의 노드(segTree[node])에 arr 배열의 값(arr[start])을 push하고 재귀를 종료한다.그 외의 경우, 아직 리프 노드에 도달하지 않았다. 세그먼트 트리에서 인덱스가 node인 노드의 자식 노드의 인덱스는 node * 2, node * 2 + 1이다. 현재 범위를 반으로 나눠 왼쪽 범위의 vector와 오른쪽 범위의 vector를 재귀를 통해 구한 후 현재 노드에 두 자식 노드 vector을 합쳐서 정렬한 vector를 만들어주고 반환한다.탐색 범위의 k보다 큰 원소를 반환하는 함수//탐색 범위의 k보다 큰 원소 개수 얻기int getCnt(int node, int start, int end, int left, int right, int k) { //탐색 범위가 얻을 범위에 포함되지 않는 경우 if (left &amp;gt; end || right &amp;lt; start) return 0; //탐색 범위가 얻을 범위에 완전히 포함되는 경우 if (left &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= right) { return segTree[node].end() - upper_bound(segTree[node].begin(), segTree[node].end(), k); } //탐색 범위가 얻을 범위에 걸치는 경우 int mid = (start + end) / 2; int leftRst = getCnt(node * 2, start, mid, left, right, k); int rightRst = getCnt(node * 2 + 1, mid + 1, end, left, right, k); return leftRst + rightRst;}left와 right는 k보다 큰 원소의 개수를 얻을 범위이며, 재귀를 거치며 변하지 않는다.탐색 범위(start ~ end)가 얻을 범위(left ~ right)에 포함되지 않는 경우, 이 부분의 반환값은 최종 결과에 영향을 미쳐서는 안 되므로 0을 반환한다.탐색 범위(start ~ end)가 얻을 범위(left ~ right)에 완전히 포함되는 경우, 세그먼트 트리에서 해당 노드 k보다 큰 원소의 개수를 반환한다. upper_bound를 이용해서 k보다 큰 가장 작은 원소가 처음 등장하는 위치를 세그먼트 트리의 마지막 원소의 다음 위치에서 뺀 값이 구하고자 하는 값이다.그 외의 경우는 탐색 범위(start ~ end)가 얻을 범위(left ~ right)에 걸치는 경우이다. 위의 두 함수와 마찬가지로 현재 범위를 반으로 나눠 각각 탐색 후 두 반환값의 합을 반환한다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt;#pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 100000int arr[MAX_N + 1];vector&amp;lt;int&amp;gt; segTree[MAX_N * 4 + 4];vector&amp;lt;int&amp;gt; makeSegTree(int node, int start, int end);int getCnt(int node, int start, int end, int left, int right, int k);int main() { int n, m; scanf(&quot;%d&quot;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) { //수열 입력받기 scanf(&quot;%d&quot;, &amp;amp;arr[i]); } makeSegTree(1, 1, n); //세그먼트 트리 만들기 scanf(&quot;%d&quot;, &amp;amp;m); for (int t = 0; t &amp;lt; m; t++) { //쿼리 입력받기 int i, j, k; scanf(&quot;%d %d %d&quot;, &amp;amp;i, &amp;amp;j, &amp;amp;k); printf(&quot;%d\\n&quot;, getCnt(1, 1, n, i, j, k)); } return 0;}// 정렬된 자식노드 vector 세그먼트 트리 만들기vector&amp;lt;int&amp;gt; makeSegTree(int node, int start, int end) { if (start == end) { segTree[node].push_back(arr[start]); return segTree[node]; } int mid = (start + end) / 2; vector&amp;lt;int&amp;gt; leftRst = makeSegTree(node * 2, start, mid); vector&amp;lt;int&amp;gt; rightRst = makeSegTree(node * 2 + 1, mid + 1, end); segTree[node] = leftRst; segTree[node].insert(segTree[node].end(), rightRst.begin(), rightRst.end()); sort(segTree[node].begin(), segTree[node].end()); return segTree[node];}//탐색 범위의 k보다 큰 원소 개수 얻기int getCnt(int node, int start, int end, int left, int right, int k) { if (left &amp;gt; end || right &amp;lt; start) return 0; //탐색 범위가 얻을 범위에 포함되지 않는 경우 if (left &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= right) { //탐색 범위가 얻을 범위에 완전히 포함되는 경우 return segTree[node].end() - upper_bound(segTree[node].begin(), segTree[node].end(), k); } //탐색 범위가 얻을 범위에 걸치는 경우 int mid = (start + end) / 2; int leftRst = getCnt(node * 2, start, mid, left, right, k); int rightRst = getCnt(node * 2 + 1, mid + 1, end, left, right, k); return leftRst + rightRst;}" }, { "title": "[백준 14438번] 수열과 쿼리 17 [C++]", "url": "/posts/boj-14438/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Segment tree", "date": "2022-01-20 00:00:00 +0900", "snippet": "14438번: 수열과 쿼리 17 문제 링크: 14438번: 수열과 쿼리 17개요배열 크기 n과 쿼리의 수 m이 최대 100,000이므로 매 구간 최솟값을 출력할 때마다 구간을 전부 탐색하는 시간복잡도 O(n×m)의 방식으로는 시간 초과와 마주할 수밖에 없다.각 구간의 최솟값을 세그먼트 트리에 저장하여 사용해야 한다. 세그먼트 트리의 개념은 아래 블로그에 잘 설명되어있다.세그먼트 트리(Segment Tree)풀이아래 설명할 세 함수는 모두 node, start, end라는 인자를 갖고 있다. node는 세그먼트 트리상에서 현재 노드의 인덱스이며, start와 end는 arr 배열 상에서의 현재 탐색 범위의 양 끝 인덱스이다. 세 함수는 모두 재귀의 형태를 가지는데, 위에서 말한 세 인자는 재귀를 거치며 segTree[node]가 arr[start]부터 arr[end]까지의 범위를 담당하는 노드임이 유지되도록 변화한다.세그먼트 트리 생성 함수//최솟값 저장하는 세그먼트 트리 만들기int makeSegTree(int node, int start, int end) { if (start == end) return segTree[node] = arr[start]; int mid = (start + end) / 2; int leftRst = makeSegTree(node * 2, start, mid); int rightRst = makeSegTree(node * 2 + 1, mid + 1, end); segTree[node] = min(leftRst, rightRst); return segTree[node];}main 함수에서 이 함수를 makeSegTree(1, 1, n)의 형태로 호출할 것이다. 세그먼트 트리의 루트 노드(1, 전체 범위 담당)부터 시작하여 재귀의 형태로 자식 노드로 뻗어 내려가고, 자식 노드의 값을 이용해 부모 노드의 값을 생성하는 방식이다.start == end인 경우, 리프 노드에 도달했다는 뜻이므로 현재 세그먼트 트리의 노드(segTree[node])에 arr 배열의 값(arr[start])을 대입하고 재귀를 중단해준다.그 외의 경우, 아직 리프 노드에 도달하지 않았다. 세그먼트 트리에서 인덱스가 node인 노드의 자식 노드의 인덱스는 node * 2, node * 2 + 1이다. 현재 범위를 반으로 나눠 왼쪽 범위의 최솟값과 오른쪽 범위의 최솟값을 재귀를 통해 구한 후 두 값 중 더 작은 값을 현재 세그먼트 트리의 노드에 저장하고 반환해준다.세그먼트 트리 업데이트 함수void updateSegTree(int node, int start, int end, int idx, int newVal) { //탐색 범위에 갱신할 위치가 포함되지 않는 경우 if (idx &amp;lt; start || end &amp;lt; idx) return; //현재 범위가 갱신할 위치의 리프 노드인 경우 if (idx == start &amp;amp;&amp;amp; start == end) { segTree[node] = newVal; return; } //갱신할 위치가 현재 탐색 범위에 포함되는 경우 int mid = (start + end) / 2; updateSegTree(node * 2, start, mid, idx, newVal); updateSegTree(node * 2 + 1, mid + 1, end, idx, newVal); segTree[node] = min(segTree[node * 2], segTree[node * 2 + 1]); //자식 노드로부터 업데이트 return;}이 함수는 arr상에서 idx의 위치에 해당하는 세그먼트 트리의 리프 노드의 값을 newVal로 업데이트해주고, 그 노드의 값에 영향받는 모든 부모 노드의 값 또한 업데이트해준다. makeSegTree 함수와 마찬가지로 main 함수에서는 updateSegTree(1, 1, n, idx, newVal)의 형태로 호출하여 루트 노드부터 시작하여 뻗어내려간다.현재 탐색 범위에 갱신할 위치가 포함되지 않는 경우, 업데이트 작업을 할 필요가 없으므로 바로 재귀를 중단해준다.현재 범위가 갱신할 위치의 리프 노드인 경우, 세그먼트 트리의 해당 노드의 값을 업데이트 해주고 재귀를 중단해준다.그 외의 경우는 현재 탐색 범위가 리프 노드가 아니며, 갱신할 위치가 포함되는 경우이다. 현재 노드는 값을 갱신할 노드의 부모 노드라는 의미이다. 따라서 makeSegTree 함수와 마찬가지로 현재 범위를 나눠 재귀를 통해 자식 노드를 업데이트 한 후, 자식 노드로부터 현재 노드의 값을 업데이트해준다.부분 합 반환 함수//탐색 범위의 최솟값 얻기int getMinVal(int node, int start, int end, int left, int right) { //탐색 범위가 얻을 범위에 포함되지 않는 경우 if (left &amp;gt; end || right &amp;lt; start) return MAX_A; //탐색 범위가 얻을 범위에 완전히 포함되는 경우 if (left &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= right) return segTree[node]; //탐색 범위가 얻을 범위에 걸치는 경우 int mid = (start + end) / 2; int leftRst = getMinVal(node * 2, start, mid, left, right); int rightRst = getMinVal(node * 2 + 1, mid + 1, end, left, right); return min(leftRst, rightRst);}left와 right는 최솟값을 얻을 범위이며, 재귀를 거치며 변하지 않는다.탐색 범위(start ~ end)가 얻을 범위(left ~ right)에 포함되지 않는 경우, 이 부분의 최솟값은 최종 결과에 영향을 미쳐서는 안 되므로 배열의 값으로 들어올 수 있는 정수 중 최댓값보다 1 큰 수를 저장해둔 MAX_A를 반환한다.탐색 범위(start ~ end)가 얻을 범위(left ~ right)에 완전히 포함되는 경우, 세그먼트 트리에서 해당 노드의 값을 반환하면 된다.그 외의 경우는 탐색 범위(start ~ end)가 얻을 범위(left ~ right)에 걸치는 경우이다. 위의 두 함수와 마찬가지로 현재 범위를 반으로 나눠 각 탐색 후 두 값 중 최솟값을 반환한다.전체 코드#include &amp;lt;iostream&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 100000#define MAX_A 1000000001int arr[MAX_N + 1], segTree[MAX_N * 4 + 4];int min(int a, int b);int makeSegTree(int node, int start, int end);void updateSegTree(int node, int start, int end, int idx, int newVal);int getMinVal(int node, int start, int end, int left, int right);int main() { int n, m; scanf(&quot;%d&quot;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) { //수열 입력받기 scanf(&quot;%d&quot;, &amp;amp;arr[i]); } makeSegTree(1, 1, n); //세그먼트 트리 만들기 scanf(&quot;%d&quot;, &amp;amp;m); for (int i = 0; i &amp;lt; m; i++) { //쿼리 입력받기 int cmd, a, b; scanf(&quot;%d %d %d&quot;, &amp;amp;cmd, &amp;amp;a, &amp;amp;b); if (cmd == 1) { //값 변경 쿼리 updateSegTree(1, 1, n, a, b); } else { //부분 최솟값 출력 쿼리 printf(&quot;%d\\n&quot;, getMinVal(1, 1, n, a, b)); } } return 0;}int min(int a, int b) { return a &amp;lt; b ? a : b;}//최솟값 저장하는 세그먼트 트리 만들기int makeSegTree(int node, int start, int end) { if (start == end) return segTree[node] = arr[start]; int mid = (start + end) / 2; int leftRst = makeSegTree(node * 2, start, mid); int rightRst = makeSegTree(node * 2 + 1, mid + 1, end); segTree[node] = min(leftRst, rightRst); return segTree[node];}//세그먼트 트리 업데이트하기void updateSegTree(int node, int start, int end, int idx, int newVal) { //탐색 범위에 갱신할 위치가 포함되지 않는 경우 if (idx &amp;lt; start || end &amp;lt; idx) return; //현재 범위가 갱신할 위치의 리프 노드인 경우 if (idx == start &amp;amp;&amp;amp; start == end) { segTree[node] = newVal; return; } //갱신할 위치가 현재 탐색 범위에 포함되는 경우 int mid = (start + end) / 2; updateSegTree(node * 2, start, mid, idx, newVal); updateSegTree(node * 2 + 1, mid + 1, end, idx, newVal); segTree[node] = min(segTree[node * 2], segTree[node * 2 + 1]); //자식 노드로부터 갱신 return;}//탐색 범위의 최솟값 얻기int getMinVal(int node, int start, int end, int left, int right) { //탐색 범위가 얻을 범위에 포함되지 않는 경우 if (left &amp;gt; end || right &amp;lt; start) return MAX_A; //탐색 범위가 얻을 범위에 완전히 포함되는 경우 if (left &amp;lt;= start &amp;amp;&amp;amp; end &amp;lt;= right) return segTree[node]; //탐색 범위가 얻을 범위에 걸치는 경우 int mid = (start + end) / 2; int leftRst = getMinVal(node * 2, start, mid, left, right); int rightRst = getMinVal(node * 2 + 1, mid + 1, end, left, right); return min(leftRst, rightRst);}" }, { "title": "[백준 4342번] 유클리드 게임 [C++]", "url": "/posts/boj-4342/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Math, Number theory, Game theory, Euclidean algorithm", "date": "2022-01-18 00:00:00 +0900", "snippet": "4342번: 유클리드 게임 문제 링크: 4342번: 유클리드 게임개요매 턴 큰 수에서 작은 수의 배수를 빼서 큰 수를 0으로 먼저 만드는 사람이 이기는 게임 이론 문제이다. 두 플레이어가 최적의 방법으로 게임을 하므로, 이번 턴에 만들 수 있는 상황 중 다음 턴에 그 상황에 처한 상대방이 질 수밖에 없는 경우가 하나라도 있으면 이번 턴의 플레이어가 승리한다는 개념을 이용한다. 유클리드 호제법을 응용하여 풀 수 있다.isWin 함수int isWin(int v, int u) { // v &amp;lt;= u 로 유지 if (v &amp;gt; u) { int tmp = v; v = u, u = tmp; } // 이번 턴에서 두 수가 나누어떨어지면 이번 턴 플레이어가 승 if (u % v == 0) return 1; // 이번 턴에서 큰 수에서 작은 수를 여러번 뺄 수 있으면 이번 턴 플레이어가 승 if (u / v &amp;gt; 1) return 1; // 다음 턴에서 상대방이 지면 이번 턴 플레이어 승 return !isWin(v, u - v);}isWin(v, u)는 이번 턴에 두 수가 v와 u일 때 이번 턴 플레이어가 승리하면 1, 패배하면 0을 반환한다. v&amp;lt;=u를 유지하도록 swap을 해주었다. v와 u에 따라 세 가지 경우로 나눠서 생각하겠다.1. u가 v로 나누어 떨어지는 경우이 경우엔 무조건 u를 0으로 만들 수 있으므로 이번 턴 플레이어가 승리한다.2. u에서 v를 여러번 뺄 수 있는 경우 (u에서 v를 나눈 몫이 2 이상인 경우)이 경우엔 이번 턴 플레이어가 만들 수 있는 경우가 두 가지 이상임을 의미한다.이번 턴의 수가 (7, 19)인 경우를 생각해보자. 이번 턴에 만들 수 있는 경우는 (7, 12)와 (5, 7)이 있다. (7, 12)를 만들어서 다음 턴으로 넘겼을 때, 다음 턴 플레이어가 만들 수 있는 경우는 (5, 7)밖에 없고, 이는 이번 턴에서 플레이어가 만들 수 있는 경우이기도 하다. 따라서 이번 턴 플레이어는 두 가지 중 자신이 이길 수 있는 경우를 선택할 수 있는 상황이라는 결론을 얻는다. (우리는 둘 중 어느 경우가 이번 턴 플레이어를 이길 수 있게 하는지 모르지만, 둘 중 한 경우는 이번 턴 플레이어를 이길 수 있게 한다는 것은 확신할 수 있다.)이를 일반화해보자. 이번 턴의 수가 (v, u)이고 u에서 v를 나눈 몫이 q라고 하면, 이번 턴에서 만들 수 있는 경우는 (v, u - v), (v, u - 2v), … (v, u - (q - 1)v), (v, u - qv)로 q가지가 있다. 우리가 주목할 것은 마지막 두 가지 경우 (v, u - (q - 1)v)와 (v, u - qv)이다.마지막에서 두 번째 경우인 (v, u - (q - 1)v)는 항상 큰 수에서 작은 수를 나눈 몫이 1이다. 그러므로 이 경우를 만들어서 넘겼을 때, 다음 턴 플레이어가 만들 수 있는 경우는 (v, u - q v)로 하나밖에 없다. 이는 이번 턴 플레이어가 만들 수 있는 마지막 경우와 같다. A경우가 이길 수 있는 경우라면 A경우의 다음 턴에서 만들어지는 유일한 경우 B경우는 질 수밖에 없는 경우임이 자명하다.따라서 u에서 v를 나눈 몫이 2 이상인 경우, 이번 턴 플레이어는 (v, u - (q - 1)v)와 (v, u - qv)중 하나를 선택해서 무조건 승리할 수 있다.3. u에서 v를 한 번밖에 못 빼는 경우 (u에서 v를 나눈 몫이 1인 경우)이 경우엔 이번 턴 플레이어가 만들 수 있는 경우의 수가 한 가지이지만, 해당 경우의 승패를 알 수 없다. 따라서 재귀를 이용해 다음 턴이 승리할 수 있는 경우(1)라면 0을 반환하고, 다음 턴이 패배하는 경우(0)라면 1을 반환한다.전체 코드#include &amp;lt;iostream&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;int isWin(int v, int u);int main4342() { int a, b; scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b); while (a != 0 &amp;amp;&amp;amp; b != 0) { if (isWin(a, b)) printf(&quot;A wins\\n&quot;); else printf(&quot;B wins\\n&quot;); scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b); } return 0;}int isWin(int v, int u) { // v &amp;lt;= u 로 유지 if (v &amp;gt; u) { int tmp = v; v = u, u = tmp; } // 이번 턴에서 두 수가 나누어떨어지면 이번 턴 플레이어가 승 if (u % v == 0) return 1; // 이번 턴에서 큰 수에서 작은 수를 여러번 뺄 수 있으면 이번 턴 플레이어가 승 if (u / v &amp;gt; 1) return 1; // 다음 턴에서 상대방이 지면 이번 턴 플레이어 승 return !isWin(v, u - v);}" }, { "title": "[백준 1774번] 우주신과의 교감 [C++]", "url": "/posts/boj-1774%EB%B2%88/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Graph, Minimum Spanning Tree", "date": "2022-01-18 00:00:00 +0900", "snippet": "1774번: 우주신과의 교감 문제 링크: 1774번: 우주신과의 교감개요최소 스패닝 트리(Minimum Spanning Tree, MST)는 주어진 그래프의 모든 정점을 연결하는 부분 그래프 중에서 사용된 간선들의 가중치 합이 최소인 트리이다. 다시 말하면 n개 노드가 있을 때, n-1개 간선만을 이용해 가장 적은 가중치로 모든 노드를 연결하는 것이다.이 문제에서 황선자씨가 모든 우주신들과 교감할 수 있도록 정신적 통로들을 만들어줘야 하므로, 최소 스패닝 트리를 구하는 알고리즘을 그대로 적용하여 풀이할 수 있다.최소 스패닝 트리를 구하는 알고리즘에는 크루스칼 알고리즘과 프림 알고리즘이 있다. 노드에 비해 간선의 개수가 적은 경우엔 크루스칼 알고리즘이, 간선의 개수가 많은 경우에는 프림 알고리즘이 더 효율적이다. 이 문제는 사실상 모든 정점이 다른 정점과 연결된 간선이 있는 것과 마찬가지이기 때문에 프림 알고리즘이 효율적일 수 있지만, 나는 효율성과 별개로 크루스칼 알고리즘을 이용해 풀이했다.크루스칼 알고리즘크루스칼 알고리즘의 전체 흐름은 다음과 같다. 간선들을 가중치에 대해 오름차순으로 정렬한다. 간선들을 순서대로 탐색하며 해당 간선의 두 노드가 현재 연결되어 있지 않다면 간선을 선택하고 아니면 건너뛴다. 모든 간선에 대해 해당 작업을 반복하여 총 n-1개의 간선이 선택된 상태에서 마무리한다.여기서 두 노드가 연결되어 있는지 확인하기 위해 Union-Find 알고리즘을 이용했다.풀이전처리//n개 노드 좌표 입력for (int i = 1; i &amp;lt;= n; i++) { scanf(&quot;%d %d&quot;, &amp;amp;posX[i], &amp;amp;posY[i]); parent[i] = i;}//입력받은 좌표로 nC2개 간선 생성for (int i = 1; i &amp;lt;= n - 1; i++) { for (int j = i + 1; j &amp;lt;= n; j++) { edges[edgesCnt].node1 = i, edges[edgesCnt].node2 = j; edges[edgesCnt].dist = pow(posX[i] - posX[j], 2) + pow(posY[i] - posY[j], 2); edgesCnt++; }}//dist 오름차순으로 간선 정렬qsort(edges, edgesCnt, sizeof(edges[0]), compare);배열 posX와 배열 posY에 n개 노드의 x좌표와 y좌표를 각각 입력받은 후, nC2개 간선(노드 개수가 n개이므로 그 중 2개를 선택하는 경우의 수는 nC2)을 생성해 구조체 배열 edges에 저장한 후, 가중치(이 문제에서는 평면상에서의 거리)에 대해 오름차순 정렬한다.Union-Find//조상 노드 찾기int getRoot(int parent[MAX_N + 1], int node) { if (parent[node] == node) return node; parent[node] = getRoot(parent, parent[node]); return parent[node];}//두 노드 union하기void unionNode(int parent[MAX_N + 1], int node1, int node2) { int root1 = getRoot(parent, node1); int root2 = getRoot(parent, node2); if (root1 &amp;lt; root2) parent[root2] = root1; else parent[root1] = root2; return;}두 노드가 연결되어 있는지를 알기 위해 두 노드의 조상 노드가 같은지를 확인한다는 것이 크루스칼 알고리즘에서 Union-Find를 이용하는 기본 아이디어이다.연결된 노드 중 번호가 작은 노드를 부모 노드로 가정하여 Union-Find를 진행한다.parent[n]은 n번 노드의 부모 노드 중 하나가 들어있으며, 그것이 항상 조상 노드라는 보장은 없다.getRoot 함수는 parent 배열을 이용해 조상 노드를 반환한다. getRoot(parent, n)을 호출하면 n번 노드에서 조상 노드까지 가기 위해 재귀를 타고 거치는 모든 노드들(k1, k2 …)에 대해 parent[k1], parent[k2]…가 해당 노드의 조상 노드로 업데이트된다. 따라서 다음번에 그 노드의 조상 노드를 찾아야 할 때 시간을 단축할 수 있다.unionNode에서는 두 노드를 연결시킨다(조상 노드를 같게 한다). 두 노드의 조상 노드 root1과 root2를 각각 구하고, 두 조상 중 번호가 큰 노드를 v, 번호가 작은 노드를 u라고 하겠다. 원래 u의 자식이었던 노드들에게는 아무 변화가 없다. 그러나 v의 자식이었던 노드들은 다음번에 getRoot의 인자로 넣어 호출하면 v까지 타고 올라간 후, parent[v]에 할당된 u가 해당 노드의 조상 노드로 업데이트된다.최소 스패닝 트리 만들기//이미 연결된 것으로 주어지는 노드 unionfor (int i = 0; i &amp;lt; m; i++) { int u, v; scanf(&quot;%d %d&quot;, &amp;amp;u, &amp;amp;v); unionNode(parent, u, v);}//크루스칼 알고리즘으로 최소 스패닝 트리 만들기for (int i = 0; i &amp;lt; edgesCnt; i++) { if (getRoot(parent, edges[i].node1) != getRoot(parent, edges[i].node2)) { sumDist += sqrt(edges[i].dist); unionNode(parent, edges[i].node1, edges[i].node2); }}이 문제에서는 이미 m개 간선으로 노드들이 연결되어있으므로 해당 노드들에 대해 unionNode를 진행해준다.그 후 가중치에 대해 오름차순으로 정렬된 간선들을 탐색한다. 두 노드의 조상 노드가 같은 경우 이미 연결된 노드들이므로 건너뛰고, 조상 노드가 다른 경우에만 unionNode를 진행하며 우리가 구해야 하는 가중치 총합에 해당 간선 가충지를 누적하면 완료이다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt;#pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 1000typedef struct edge { int node1, node2; long long dist;} Edge;int compare(const void *a, const void *b);int getRoot(int parent[MAX_N + 1], int node);void unionNode(int parent[MAX_N + 1], int node1, int node2);int main() { int n, m, parent[MAX_N + 1]; double sumDist = 0; int posX[MAX_N + 1], posY[MAX_N + 1], edgesCnt = 0; Edge edges[MAX_N * MAX_N]; scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); //n개 노드 좌표 입력 for (int i = 1; i &amp;lt;= n; i++) { scanf(&quot;%d %d&quot;, &amp;amp;posX[i], &amp;amp;posY[i]); parent[i] = i; } //입력받은 좌표로 nC2개 간선 생성 for (int i = 1; i &amp;lt;= n - 1; i++) { for (int j = i + 1; j &amp;lt;= n; j++) { edges[edgesCnt].node1 = i, edges[edgesCnt].node2 = j; edges[edgesCnt].dist = pow(posX[i] - posX[j], 2) + pow(posY[i] - posY[j], 2); edgesCnt++; } } //dist 오름차순으로 간선 정렬 qsort(edges, edgesCnt, sizeof(edges[0]), compare); //이미 연결된 것으로 주어지는 노드 union for (int i = 0; i &amp;lt; m; i++) { int u, v; scanf(&quot;%d %d&quot;, &amp;amp;u, &amp;amp;v); unionNode(parent, u, v); } //크루스칼 알고리즘으로 최소 스패닝 트리 만들기 for (int i = 0; i &amp;lt; edgesCnt; i++) { if (getRoot(parent, edges[i].node1) != getRoot(parent, edges[i].node2)) { sumDist += sqrt(edges[i].dist); unionNode(parent, edges[i].node1, edges[i].node2); } } printf(&quot;%.2lf&quot;, sumDist); return 0;}//qsort를 위한 비교 함수int compare(const void *a, const void *b) { if (((Edge *)a)-&amp;gt;dist &amp;gt; ((Edge *)b)-&amp;gt;dist) return 1; else return -1;}//조상 노드 찾기int getRoot(int parent[MAX_N + 1], int node) { if (parent[node] == node) return node; parent[node] = getRoot(parent, parent[node]); return parent[node];}//두 노드 union하기void unionNode(int parent[MAX_N + 1], int node1, int node2) { int root1 = getRoot(parent, node1); int root2 = getRoot(parent, node2); if (root1 &amp;lt; root2) parent[root2] = root1; else parent[root1] = root2; return;}" }, { "title": "[백준 11438번] LCA 2 [C++]", "url": "/posts/boj-11438/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Data structure, Tree, Lowest common ancestor", "date": "2022-01-08 00:00:00 +0900", "snippet": "11438번: LCA 2 문제 링크: 11438번: LCA 2개요최소 공통 조상(Lowest common ancestor, LCA)는 트리에 어떤 두 정점 u와 v가 있을 때, u 자신이거나 u의 조상인 동시에 v 자신이거나 v의 조상인 노드들 중 가장 깊은 노드이다. LCA 알고리즘의 기본 흐름은 다음과 같다. 두 정점 중 깊이가 더 깊은 정점에서 출발한다. 다른 정점의 깊이와 같아질 때까지 부모 노드로 이동한다. 깊이가 같은 두 정점에서 동시에 출발하여 부모 노드로 이동한다. 한 노드에서 만났을 때 이동을 종료한다. 만난 노드가 LCA이며, 총 이동 횟수가 두 노드 간의 최소 거리이다.전처리 (depth 배열과 parent 배열)vector&amp;lt;int&amp;gt; tree[MAX_N + 1];int parent[MAX_N + 1][MAX_LOG_N]; //parent[n][k] : 노드 n의 2^k번째 부모int depth[MAX_N + 1] = { 0 };tree[i]는 노드 i와 연결된 모든 노드의 번호를 저장하는 vector이며, depth[i]은 노드 i의 깊이를 저장한다. 노드 1은 루트 노드이기 때문에 depth[1]은 0이다.i번째 노드의 1번째 부모가 parent[i]인 일차원 배열을 사용해도 위에서 말한 흐름을 따라가며 LCA를 찾을 수 있다. 그러나 해당 방식은 부모 노드로 타고 올라가는 과정의 시간 복잡도가 O(n)이기 때문에 전체 시간 복잡도가 O(n*m)이 되어 이 문제에서는 시간 초과가 발생하게 된다. 따라서 노드 n의 2^k번째 부모(1번째 부모가 바로 위의 노드)를 parent[n][k]에 저장하는 이차원 배열을 사용했다.parent[n][0]와 depth 배열 채우기void explore(int currNode) { for (int i = 0; i &amp;lt; tree[currNode].size(); i++) { int nextNode = tree[currNode][i]; if (depth[nextNode] == -1) { parent[nextNode][0] = currNode; depth[nextNode] = depth[currNode] + 1; explore(nextNode); } } return;}일반적인 DFS의 형태를 가진 재귀 함수이다. 메인 함수에서 explore(1)을 호출하여 루트 노드인 1에서부터 출발해 자식 노드로 내려가며 각 노드의 depth와 parent[n][0] (노드 n의 첫 번째 부모) 에 값을 넣어준다.parent 배열 나머지 채우기for (int j = 0; j &amp;lt; MAX_LOG_N; j++) { for (int i = 2; i &amp;lt;= n; i++) { if (parent[i][j] != -1) { parent[i][j + 1] = parent[parent[i][j]][j]; } }}explore() 함수가 실행되면서 parent[n][0]만 채워졌다. 노드 n의 2^k번째 부모를 parent[n][k]에 넣어줘야 한다. 어떤 노드 i의 j번째 조상의 j번째 조상은 i의 2*j번째 조상이고, 이는 곧 parent[i][j + 1]이다. 따라서 parent[i][j + 1]는 parent[parent[i][j]][j]의 형태로 나타낼 수 있다.쿼리 처리하기depth[u] &amp;gt;= depth[v]로 유지if (depth[u] &amp;lt; depth[v]) { int tmp = u; u = v, v = tmp; };이후 작업을 편하게 하기 위해 u의 깊이가 v의 깊이보다 깊거나 같게 되도록 조건문을 추가했다.두 노드의 깊이 맞추기int diff = depth[u] - depth[v];for (int j = 0; diff &amp;gt; 0; j++) { if (diff % 2 == 1) u = parent[u][j]; diff /= 2;}두 노드의 깊이 차이를 diff에 저장해놓고, u의 깊이가 v의 깊이와 같아질 때까지 parent[u]를 이용해 u를 부모 노드로 이동시키는 작업이다. j는 밑이 2인 로그 스케일로 변화하는 변수이기 때문에 2진수 변환과 같은 방법을 이용했다. 부모 노드로 한 칸씩 이동하는 방법보다 훨씬 빠르게 두 노드의 깊이를 맞출 수 있다.LCS 구하기if (u != v) { for (int j = MAX_LOG_N - 1; j &amp;gt;= 0; j--) { if (parent[u][j] != -1 &amp;amp;&amp;amp; parent[u][j] != parent[v][j]) { u = parent[u][j]; v = parent[v][j]; } } u = parent[u][0];}printf(&quot;%d\\n&quot;, u);두 노드의 깊이가 같아졌으므로 부모 노드가 다른 동안 부모 노드로 한 칸씩 이동해준다. 이동 후 u와 v는 LCS의 바로 자식 노드이기 때문에 마지막으로 한 칸 더 이동 후 출력해준다.전체 코드#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)using namespace std;#define MAX_N 100000#define MAX_LOG_N 18vector&amp;lt;int&amp;gt; tree[MAX_N + 1];int parent[MAX_N + 1][MAX_LOG_N]; //parent[n][k] : n번째 노드의 2^k번째 부모int depth[MAX_N + 1] = { 0 };void explore(int);int main() { int n, m; scanf(&quot;%d&quot;, &amp;amp;n); //트리 입력받기 for (int i = 0; i &amp;lt; n - 1; i++) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; tree[a].push_back(b); tree[b].push_back(a); } //depth, parent 배열 초기화 for (int i = 1; i &amp;lt;= n; i++) { depth[i] = -1; for (int j = 0; j &amp;lt; MAX_LOG_N; j++) { parent[i][j] = -1; } } depth[1] = 0; //parent[n][0]과 depth 배열 채우기 explore(1); //parent 배열 채우기 for (int j = 0; j &amp;lt; MAX_LOG_N; j++) { for (int i = 2; i &amp;lt;= n; i++) { if (parent[i][j] != -1) { parent[i][j + 1] = parent[parent[i][j]][j]; } } } //쿼리 입력받기 scanf(&quot;%d&quot;, &amp;amp;m); while (m--) { int u, v; scanf(&quot;%d %d&quot;, &amp;amp;u, &amp;amp;v); //depth[u] &amp;gt;= depth[v]로 유지 if (depth[u] &amp;lt; depth[v]) { int tmp = u; u = v, v = tmp; }; int diff = depth[u] - depth[v]; //두 노드의 깊이 맞추기 for (int j = 0; diff &amp;gt; 0; j++) { if (diff % 2 == 1) u = parent[u][j]; diff /= 2; } if (u != v) { for (int j = MAX_LOG_N - 1; j &amp;gt;= 0; j--) { if (parent[u][j] != -1 &amp;amp;&amp;amp; parent[u][j] != parent[v][j]) { u = parent[u][j]; v = parent[v][j]; } } u = parent[u][0]; } printf(&quot;%d\\n&quot;, u); } return 0;}void explore(int currNode) { for (int i = 0; i &amp;lt; tree[currNode].size(); i++) { int nextNode = tree[currNode][i]; if (depth[nextNode] == -1) { parent[nextNode][0] = currNode; depth[nextNode] = depth[currNode] + 1; explore(nextNode); } } return;}" }, { "title": "[Unity] 객체 지향과 유니티 기초 개념", "url": "/posts/oop-unity-basic/", "categories": "Unity", "tags": "", "date": "2021-12-30 00:00:00 +0900", "snippet": "객체 지향의 개념객체 지향이란 프로그래밍 패러다임 중 하나이다. 기존에는 프로그램을 명령어의 모음으로 인식했으며, 명령어의 순서에 초점을 맞춘 절차지향 프로그래밍이 사용되었다. 그러나 객체지향은 프로그램을 독립된 단위인 객체들과, 각 객체들 간의 상호작용에 초점을 맞춘다.클래스클래스는 객체 지향 프로그래밍에서 객체의 상태를 나타내는 멤버 변수와 객체와 관련 있는 함수인 메소드로 이루어진 일종의 설계도이다. 인스턴스는 클래스로부터 만들어진 실체이며, 각 멤버변수가 실제로 값을 가진다. 클래스의 속성 중 일부를 상속받는 서브 클래스를 가질 수 있으며, 자신은 그 서브클래스에 대해 수퍼 클래스가 된다.메소드메소드(멤버 함수)는 객체와 관련된 클래스 내에 정의된 함수이며, 멤버 변수에 접근 권한을 갖는다. 생성된 인스턴스가 갖고 있는 인스턴스 변수에 접근하는 메소드를 인스턴스 메소드라고 한다. 인스턴스 메소드는 인스턴스를 생성해야만 만들어지고, 호출할 수 있게 된다. 모든 인스턴스가 공유하는 클래스 메소드에 접근하는 메소드를 클래스 메소드라고 한다. 클래스 메소드는 인스턴스의 생성 없이도 호출이 가능하다.접근제한객체 지향에서 정보 은닉은 중요한 개념이다. 클래스 외부에서 접근할 필요가 없는 정보는 외부로부터의 접근을 제한함으로써 객체 간의 결합도를 약화시켜 유연성을 확보할 수 있다. 각 언어에서 제공하는 접근 제어사를 이용해 어떤 멤버에 대한 외부의 접근을 허용하거나 차단할 수 있다. private 멤버는 해당 멤버를 선언한 클래스의 멤버만 접근이 가능하며, public 멤버는 프로그램 어디에서나 접근할 수 있다. protected 멤버는 이 멤버를 선언한 클래스의 멤버, 이 멤버를 선언한 클래스가 속한 패키지의 멤버, 이 멤버를 선언한 클래스를 상속받은 서브 클래스의 멤버가 접근할 수 있다.상속클래스 간의 관계는 상속 관계와 포함 관계가 있다.상속해주는 클래스를 수퍼 클래스, 상속받는 클래스를 수퍼 클래스의 서브 클래스라고 하며, 이 클래스들의 관계를 상속 관계에 있다고 한다. 서브 클래스는 수퍼 클래스에 있는 멤버가 자동으로 추가된 것과 같은 효과를 얻는다. 어떤 클래스를 상속받을 때, 그 클래스에 선언된 멤버뿐만 아니라 그 클래스가 상속받은 멤버를 모두 상속받는다. 수퍼 클래스 A, 서브 클래스 B가 있다고 할 때 “B는 A이다.”라는 문장이 성립해야 한다.포함 관계는 클래스가 다른 클래스를 포함하는 관계이다. 한 클래스의 멤버 변수로 다른 클래스의 인스턴스를 가지면서 만들어진다. 포함 관계는 합성 관계(강한 관계)와 집합 관계(약한 관계)로 구분된다. 상속과 포함을 통해 클래스의 재사용성을 높여 중복 작업을 줄일 수 있으며, 일관성을 유지하기 쉬워진다.유니티 게임 오브젝트게임 오브젝트는 캐릭터, 소품, 건물뿐만 아니라 광원, 카메라 등을 포함한 게임을 구성하는 모든 요소이다. 유니티에서 모든 게임 오브젝트들은 GameObject라는 타입의 변수이며, 해당 오브젝트의 속성인 컴포넌트들을 담는 컨테이너라 할 수 있다.컴포넌트컴포넌트는 게임 오브젝트를 이루는 조각들이다. 게임 오브젝트에 Transform 컴포넌트를 붙여 크기, 위치, 회전 정보를 지정할 수 있고, Box Collider 컴포넌트를 붙여 다른 물체와 부딪힐 수 있는 물리적 표면을 만들 수 있으며, Light 컴포넌트를 붙여 광원으로 사용할 수 있다. 기본으로 제공하는 컴포넌트 외에도 커스텀 컴포넌트인 C# 스크립트를 만들어 붙일 수 있다." }, { "title": "[백준 10159번] 저울 [C언어]", "url": "/posts/boj-10159/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Graph, Floyd–Warshall", "date": "2021-11-14 00:00:00 +0900", "snippet": "10159번: 저울 문제 링크: 10159번: 저울개요어떤 정점에서 다른 정점으로 가는 최단경로를 알고 싶을 때 사용하는 알고리즘은 대표적으로 다익스트라(Dijkstra) 알고리즘과 플로이드 와샬(Floyd–Warshall) 알고리즘이 있다. 플로이드 와샬 알고리즘은 3중 반복문을 사용하기 때문에 우선순위 큐를 사용하지 않는 다익스트라 알고리즘의 시간복잡도(O(n²))보다도 더 큰 시간복잡도(O(n³))를 갖는다. 하지만 한 정점에서부터의 최단경로를 알게 되는 다익스트라 알고리즘과는 달리 모든 정점에서 모든 정점으로의 최단 경로를 알 수 있다는 장점이 있다. 이 문제에서는 모든 정점에 대해 최단 경로를 알 수 있는 정점 개수를 각각 출력해야 하기 떄문에 플로이드 와샬 알고리즘이 적합하다.플로이드 와샬2차원 배열 dist[i][j]는 i에서 j로 가는 최단 경로를 저장하는 것이 아니라, i가 j보다 무거우면 1, 가벼우면 -1, 알 수 없으면 0을 저장했다. for (int i = 0; i &amp;lt; m; i++) { int a, b; scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b); dist[a][b] = 1, dist[b][a] = -1; } for (int k = 1; k &amp;lt;= n; k++) { for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (dist[i][k] &amp;amp;&amp;amp; dist[i][k] == dist[k][j]) { dist[i][j] = dist[i][k]; } } } }k를 거쳐서 i와 j를 비교할 때, w(i) &amp;lt; w(k) &amp;lt; w(j) 이거나 w(i) &amp;gt; w(k) &amp;gt; w(j) 이어야만 w(i)와 w(j)의 대소관계를 알 수 있다. 따라서 dist[i][k]와 dist[k][j]가 같은 경우에만 dist[i][j]를 갱신해주었다. (w(n) = n의 무게)전체 코드#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)#define MAX_N 100int main() { int n, m, dist[MAX_N+1][MAX_N+1] = { 0 }; scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); for (int i = 0; i &amp;lt; m; i++) { int a, b; scanf(&quot;%d %d&quot;, &amp;amp;a, &amp;amp;b); dist[a][b] = 1, dist[b][a] = -1; } for (int k = 1; k &amp;lt;= n; k++) { for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (dist[i][k] &amp;amp;&amp;amp; dist[i][k] == dist[k][j]) { dist[i][j] = dist[i][k]; } } } } for (int i = 1; i &amp;lt;= n; i++) { int crCnt = 0; for (int j = 1; j &amp;lt;= n; j++) { if (!dist[i][j]) crCnt++; } printf(&quot;%d\\n&quot;, crCnt - 1); } return 0;}" }, { "title": "[백준 17822번] 원판 돌리기 [C언어]", "url": "/posts/boj-17822/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon, Implementation, Simulation", "date": "2021-11-11 00:00:00 +0900", "snippet": "17822번: 원판 돌리기 문제 링크: 17822번: 원판 돌리기개요시키는 대로 구현만 잘 하면 되는 시뮬레이션 문제이다. n(원판의 개수), m(한 원판 안의 숫자 개수), k(원판 회전 횟수)가 최대 50으로 작기 때문에 회전을 직접 이동시켜서 구현해도 시간초과가 발생하지 않을 듯 하지만(*진위여부 파악 필요) 나는 원판을 회전시키지 않고 각 원판이 얼마나 회전된 상태인지를 따로 저장한 값으로 매번 인덱스를 보정하여 사용하는 방법으로 회전을 구현했다. 사용하는 배열들을 굳이 동적 할당으로 할당받아야 할 이유는 없지만 단순히 연습을 위해 동적 할당을 이용했다. 동적 할당 시 마지막에 메모리 해제하는 것을 잊지 말자.회전 구현1차원 int형 배열 rot의 0번 위치부터 n-1번 위치까지를 (n+1)번째 판이 회전된 정도를 저장하는 데에 사용했다.int xi, di, ki;scanf(&quot;%d %d %d&quot;, &amp;amp;xi, &amp;amp;di, &amp;amp;ki);di = di * 2 - 1;for (int x = xi; x &amp;lt;= n; x+=xi) { rot[x-1] += di * ki + m; rot[x - 1] %= m;}di는 시계방향일 때 0, 반시계방향일 때 1이 입력되는데 시계방향일 때 -1, 반시계방향일 때 1로 만들고 싶기 때문에 (di * 2 - 1)로 바꿔주었다. 방향을 나타내는 di와 회전 칸수를 나타내는 ki를 곱해 rot 배열의 해당 위치에 더해준다. 이 때 한 원판의 숫자 개수를 나타내는 m을 더한 후 다시 m으로 모듈러 연산을 해주었는데 이렇게 하지 않으면 int 오버플로우가 발생하여(*추정) 0%에서 ‘틀렸습니다!’가 나온다. (이것 때문에 시간을 무진장 많이 잡아먹었다.)int rotdY(int x, int y) { return (y + m + rot[x]) % m;}보정할 값을 저장했으면 해당 값으로 인덱스를 보정해주어야 한다. 코드의 간결함을 위해 함수로 분리해서 사용했다. arr[i][j]에 접근할 때 항상 arr[i][(rotdY[i], j)] 꼴로 사용했다.인접한 같은 숫자 삭제하기 구현int deleteSameNum(int x0, int y0, int vstd[][50], int depth) { int dx[4] = { 0, 0, 1, -1 }; int dy[4] = { 1, -1, 0, 0 }; if (!exist[x0][rotdY(x0, y0)] || vstd[x0][rotdY(x0, y0)]) return 0; int existSame = 0; vstd[x0][rotdY(x0, y0)] = 1; for (int d = 0; d &amp;lt; 4; d++) { int x = x0 + dx[d]; int y = y0 + dy[d]; if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; arr[x0][rotdY(x0, y0)] == arr[x][rotdY(x, y)]) { existSame = 1; deleteSameNum(x, y, vstd, depth + 1); } } if (depth || existSame) arr[x0][rotdY(x0, y0)] = 0, exist[x0][rotdY(x0, y0)] = 0; return existSame;}일반적인 dfs로 구현했다. 2차원 배열에서 인접한 수를 탐색하는 것과 방법은 같지만 이 문제에서는 시작과 끝이 연결된 원형이기 때문에 가로방향 인덱스는 보정된 값을 사용하고, 한계 조건을 걸지 않았다는 차이가 있다. 깊이가 0일 때는 상하좌우 중 한 곳 이상에 같은 값이 있을 때만, 깊이가 1 이상일 때는 조건 상관 없이 해당 숫자를 삭제하고 숫자의 존재 여부를 체크하는 배열 exist의 해당 위치를 0으로 바꿔주었다.유의사항 원판을 회전시킬 때, 입력받은 원판 번호(xi)의 배수인 원판을 모두 회전시켜야 하기 때문에 for (int x = xi; x &amp;lt;= n; x+=xi) 와 같은 형태의 반복문을 사용했다. for (int x = xi; x &amp;lt;= n; x+=x) 와 같이 자기 자신을 다시 더하면 안 된다. 원본 삼성 역량테스트 기출 문제에서는 평균 값을 내림하여 사용했지만 이 문제에서는 내림하지 않는다. 부동소수 자료형으로 저장해서 사용하자. 배열을 꼭 초기화 후 사용하자. 처음에 rot 배열을 초기화하지 않고 쓰레기값이 들어간 상태로 사용해서 엉뚱한 인덱스로 접근하는 일이 발생했다.전체 코드#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #pragma warning(disable:4996)#pragma warning(disable:6031)int n, m, t, **arr, *rot, **exist;int deleteSameNum(int, int, int [][50], int);int rotdY(int, int);double getAvg();int main() { scanf(&quot;%d %d %d&quot;, &amp;amp;n, &amp;amp;m, &amp;amp;t); arr = malloc(sizeof(int *) * n); if (arr == NULL) return -1; exist = malloc(sizeof(int *) * n); if (exist == NULL) return -1; rot = malloc(sizeof(int) * n); if (rot == NULL) return -1; for (int i = 0; i &amp;lt; n; i++) { arr[i] = malloc(sizeof(int) * m); if (arr[i] == NULL) return -1; exist[i] = malloc(sizeof(int) * m); if (exist[i] == NULL) return -1; for (int j = 0; j &amp;lt; m; j++) { scanf(&quot;%d&quot;, &amp;amp;arr[i][j]); exist[i][j] = 1; } rot[i] = 0; } for (int tc = 0; tc &amp;lt; t; tc++) { int vstd[50][50] = { 0 }; int xi, di, ki; scanf(&quot;%d %d %d&quot;, &amp;amp;xi, &amp;amp;di, &amp;amp;ki); di = di * 2 - 1; for (int x = xi; x &amp;lt;= n; x+=xi) { rot[x-1] += di * ki + m; rot[x - 1] %= m; } int existSame = 0; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (deleteSameNum(i, j, vstd, 0)) existSame = 1; } } if (!existSame) { double avg = getAvg(); for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (exist[i][j] &amp;amp;&amp;amp; arr[i][j] &amp;gt; avg) arr[i][j]--; else if (exist[i][j] &amp;amp;&amp;amp; arr[i][j] &amp;lt; avg) arr[i][j]++; } } } } int sum = 0; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (exist[i][rotdY(i, j)]) sum += arr[i][rotdY(i, j)]; } } printf(&quot;%d&quot;, sum); for (int i = 0; i &amp;lt; n; i++) { if (arr[i]) free(arr[i]); if (exist[i]) free(exist[i]); } if (arr) free(arr); if (exist) free(exist); if (rot) free(rot); return 0;}int deleteSameNum(int x0, int y0, int vstd[][50], int depth) { int dx[4] = { 0, 0, 1, -1 }; int dy[4] = { 1, -1, 0, 0 }; if (!exist[x0][rotdY(x0, y0)] || vstd[x0][rotdY(x0, y0)]) return 0; int existSame = 0; vstd[x0][rotdY(x0, y0)] = 1; for (int d = 0; d &amp;lt; 4; d++) { int x = x0 + dx[d]; int y = y0 + dy[d]; if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; arr[x0][rotdY(x0, y0)] == arr[x][rotdY(x, y)]) { existSame = 1; deleteSameNum(x, y, vstd, depth + 1); } } if (depth || existSame) arr[x0][rotdY(x0, y0)] = 0, exist[x0][rotdY(x0, y0)] = 0; return existSame;}int rotdY(int x, int y) { return (y + m + rot[x]) % m;}double getAvg() { int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (exist[i][j]) cnt++, sum += arr[i][j]; } } if (!cnt) return 0.0; return (double)sum / cnt;}" }, { "title": "[백준 2143번] 두 배열의 합 [C언어]", "url": "/posts/boj-2143/", "categories": "Baekjoon", "tags": "Algorithm, Baekjoon", "date": "2021-10-26 00:00:00 +0900", "snippet": "2143번: 두 배열의 합 문제 링크: 2143번: 두 배열의 합전체 코드#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt;#pragma warning(disable:4996)#pragma warning(disable:6031)#define MAX_LEN 1000int cmp(const void *a, const void *b);void inputArr(int *arr, int len);void makePrtlSum(int *orgnArr, int *newArr, int len, int *pIdx);int main() { int s, len1, len2, arr1[MAX_LEN + 1] = { 0 }, arr2[MAX_LEN + 1] = { 0 }; int prtlSum1[MAX_LEN * MAX_LEN], prtlSum2[MAX_LEN * MAX_LEN], sumIdx1 = 0, sumIdx2 = 0; long long cnt = 0; scanf(&quot;%d %d&quot;, &amp;amp;s, &amp;amp;len1); inputArr(arr1, len1); scanf(&quot;%d&quot;, &amp;amp;len2); inputArr(arr2, len2); makePrtlSum(arr1, prtlSum1, len1, &amp;amp;sumIdx1); makePrtlSum(arr2, prtlSum2, len2, &amp;amp;sumIdx2); qsort(prtlSum1, sumIdx1, sizeof(int), cmp); qsort(prtlSum2, sumIdx2, sizeof(int), cmp); int i0 = 0, j0 = sumIdx2 - 1; while (i0 &amp;lt; sumIdx1 &amp;amp;&amp;amp; j0 &amp;gt;= 0) { if (prtlSum1[i0] + prtlSum2[j0] == s) { long long currCnt = 0; int i, j; for (i = i0; prtlSum1[i0] == prtlSum1[i] &amp;amp;&amp;amp; i &amp;lt; sumIdx1; i++); for (j = j0; prtlSum2[j0] == prtlSum2[j] &amp;amp;&amp;amp; j &amp;gt;= 0; j--); cnt += (long long)(i - i0) * (j0 - j); i0 = i, j0 = j; } else if (prtlSum1[i0] + prtlSum2[j0] &amp;lt; s) i0++; else j0--; } printf(&quot;%lld&quot;, cnt); return 0;}void inputArr(int *arr, int len) { for (int i = 1; i &amp;lt;= len; i++) { scanf(&quot;%d&quot;, &amp;amp;arr[i]); arr[i] += arr[i - 1]; } return;}void makePrtlSum(int *orgnArr, int *newArr, int len, int *pIdx) { for (int i = 1; i &amp;lt;= len; i++) { for (int j = 0; j &amp;lt; i; j++) { newArr[(*pIdx)++] = orgnArr[i] - orgnArr[j]; } } return;}int cmp(const void *a, const void *b) { if (*(int *)a &amp;gt; *(int *)b) return 1; if (*(int *)a &amp;lt; *(int *)b) return -1; return 0;}" }, { "title": "[CS] 여러가지 정렬 알고리즘", "url": "/posts/sorting-algorithms/", "categories": "Computer Science", "tags": "Algorithm, Sort", "date": "2021-05-13 00:00:00 +0900", "snippet": "빅오 표기법빅오 표기법(big-O notation)은 점근표기법 중 하나로, 알고리즘의 성능을 상한선을 기준으로 하여 수학적으로 표기하는 방법이다. 알고리즘의 시간 복잡도(시간 효율성)과 공간 복잡도(메모리 공간 효율성)를 나타낼 수 있다. 여기서 알고리즘의 시간 복잡도는 실제 알고리즘의 러닝타임을 의미하는 것이 아닌, 데이터나 사용자 수의 증가에 따른 알고리즘의 성능 변화를 예측하는 것이 목적이다.빅오 표기법의 정의는 아래와 같다.💡 어떤 함수 𝑓(𝑛)의 빅오 표기법이 𝑂(𝑔(𝑛))이라는 것은,𝑛 &amp;gt; 𝑛₀ 을 만족하는 충분히 큰 모든 𝑛에 대해 𝑓(𝑛) ≤ 𝑐𝑔(𝑛) 인양수 𝑐와 𝑛₀가 존재한다는 것이다.𝑂(1)상수형. 입력 데이터의 크기와 상관 없이 항상 일정한 연산 횟수를 가진다.for(int i = 0; i &amp;lt; 10; i++)𝑂(𝚕𝚘𝚐𝑛)로그형. (ex : 이진 탐색)for(int i = n; i &amp;gt; 0; i/=2)𝑂(𝑛)선형. 입력 데이터의 크기와 연산 횟수가 비례한다. (ex : 최댓값 찾기)for(int i = 0; i &amp;lt; n; i++)𝑂(𝑛𝚕𝚘𝚐𝑛)선형로그형. (ex : 퀵 정렬, 합병 정렬)for(int i = 0; i &amp;lt; n; i++) for(int j = i; j &amp;gt; 0; j/=2)𝑂(𝑛²)평방형. (ex : 버블 정렬, 삽입 정렬)for(int i = 0; i &amp;lt; n; i++) for(int j = 0; j &amp;lt; n; j++)𝑂(𝑛³)입방형.for(int i = 0; i &amp;lt; n; i++) for(int j = 0; j &amp;lt; n; j++) for(int k = 0; k &amp;lt; n; k++)𝑂(2ⁿ)지수형. (ex : 피보나치수열)int fibonacci(int n) { if(n == 0 || n == 1) return 1; return fibonacci(n-1) + fibonacci(n-2);}정렬 알고리즘선택 정렬제자리 정렬 알고리즘의 하나이다. 첫번째 자료와 두 번째부터 n번째 자료까지 전부 비교하여 가장 크거나 작은 값을 찾아 첫번째 자리에 놓는다. 이후에는 두 번째부터 n-1번째 자료까지 같은 작업을 반복하면 정렬이 완료된다. 𝑂(𝑛²)의 시간 복잡도를 갖는다.// 5개 정수를 오름차순으로 선택 정렬하여 출력하는 코드#include &amp;lt;stdio.h&amp;gt;int main() { int arr[5] = { 7, 9, 1, 4, 3 }; int n = 5; for (int i = 0; i &amp;lt; n - 1; i++) { for (int j = i; j &amp;lt; n; j++) { if (arr[i] &amp;gt; arr[j]) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } } for (int i = 0; i &amp;lt; n; i++) printf(&quot;%d &quot;, arr[i]); return 0;}삽입 정렬두 번째 자료부터 시작하여 그 왼쪽의 이미 정렬된 자료들과 비교하여 삽입할 위치를 정하고 그 위치보다 오른쪽에 있던 자료들을 한 칸씩 오른쪽으로 옮긴 후 원하는 자리에 자료를 삽입한다. 이 작업을 두 번째 자료부터 n번째 자료까지 반복하면 정렬이 완료된다. 𝑂(𝑛²)의 시간 복잡도를 갖는다.// 5개 정수를 오름차순으로 삽입 정렬하여 출력하는 코드#include &amp;lt;stdio.h&amp;gt;int main() { int arr[5] = { 7, 9, 1, 4, 3 }; int n = 5; for (int i = 1; i &amp;lt; n; i++) { int curnum = arr[i], isput = 0; for (int j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; isput == 0; j--) { if (curnum &amp;lt; arr[j]) arr[j + 1] = arr[j]; else { arr[j + 1] = curnum; isput = 1; } } if (isput == 0) arr[0] = curnum; } for (int i = 0; i &amp;lt; n; i++) printf(&quot;%d &quot;, arr[i]); return 0;}버블 정렬첫 번째 원소와 두 번째 원소를 비교해 교환하고, 두 번째 원소와 세 번째 원소를 비교해 교환한다. 이 작업을 n-1번째 원소와 n번째 원소까지 반복하면 가장 크거나 작은 값이 n번 자리에 있게 된다. 전체 작업을 반복하면 그 다음으로 크거나 작은 값이 순서대로 n-1, n-2, … 번째 자리에 있게 되어 정렬이 완료된다. 𝑂(𝑛²)의 시간 복잡도를 갖는다.// 5개 정수를 오름차순으로 버블 정렬하여 출력하는 코드#include &amp;lt;stdio.h&amp;gt;int main() { int arr[5] = { 7, 9, 1, 4, 3 }; int n = 5; for (int i = n - 1; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt; i; j++) { if (arr[j] &amp;gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } for (int i = 0; i &amp;lt; n; i++) printf(&quot;%d &quot;, arr[i]); return 0;}합병 정렬하나의 리스트를 균등한 크기의 두 개의 리스트로 분할한 다음 분할된 부분 리스트를 정렬한 뒤, 두 개의 정렬된 부분 리스트를 합하여 정렬된 전체 리스트가 되게 하는 방법이다. 분할 정복 알고리즘의 하나이다. 𝑂(𝑛𝚕𝚘𝚐𝑛)의 시간복잡도를 가진다.// 8개 정수를 오름차순으로 합병 정렬하여 출력하는 코드// https://jaehee-developer.tistory.com/12 의 코드 참고하여 작성함#include &amp;lt;stdio.h&amp;gt;void divide(int arr[], int, int);void merge(int arr[], int, int, int);int main() { int myarr[8] = { 12, 3, 7, 9, 1, 14, 3, 10 }; int n = 8; divide(myarr, 0, n - 1); for (int i = 0; i &amp;lt; n; i++) printf(&quot;%d &quot;, myarr[i]); return 0;}void divide(int arr[], int l, int r) { int m; //배열을 반으로 나눈 뒤 재귀적으로 작은 배열부터 merge if (l &amp;lt; r) { m = (l + r) / 2; divide(arr, l, m); divide(arr, m + 1, r); merge(arr, l, m, r); }}void merge(int arr[], int a, int b, int c) { int i = a, j = b + 1, k = a; int tmparr[8]; //두 배열 중 하나가 끝나기 전까지 정렬하며 병합 while (i &amp;lt;= b &amp;amp;&amp;amp; j &amp;lt;= c) { if (arr[i] &amp;lt; arr[j]) tmparr[k++] = arr[i++]; else tmparr[k++] = arr[j++]; } //나머지 값들도 복사 while (i &amp;lt;= b) tmparr[k++] = arr[i++]; while (j &amp;lt;= c) tmparr[k++] = arr[j++]; for (int s = a; s &amp;lt;= c; s++) arr[s] = tmparr[s];}퀵 정렬기준값(pivot)을 설정한 후, pivot보다 작은 값을 왼쪽에, pivot보다 큰 값을 오른쪽에 몰아서 배열한다. 각 부분에서 앞의 작업을 반복해주면 오름차순 배열이 완료된다. 최악의 경우 𝑂(𝑛²)의 시간복잡도를, 평균적으로 𝑂(𝑛𝚕𝚘𝚐𝑛)의 시간복잡도를 가진다.// 8개 정수를 오름차순으로 퀵 정렬하여 출력하는 코드// https://jaehee-developer.tistory.com/14 의 코드 참고하여 작성함#include &amp;lt;stdio.h&amp;gt;void divide(int arr[], int, int);int getPivot(int arr[], int, int);int main() { int myarr[8] = { 12, 3, 7, 9, 1, 14, 3, 10 }; int n = 8; divide(myarr, 0, n - 1); for (int i = 0; i &amp;lt; n; i++) printf(&quot;%d &quot;, myarr[i]); return 0;}void divide(int arr[], int start, int end) { if (start &amp;lt; end) { int pivot = getPivot(arr, start, end); divide(arr, start, pivot - 1); divide(arr, pivot + 1, end); }}int getPivot(int arr[], int start, int end) { int i = start - 1, j, pivot = arr[end], tmp; // pivot보다 작은 요소들을 배열의 앞에 모으기 for (int j = start; j &amp;lt; end; j++) { if (arr[j] &amp;lt;= pivot) { tmp = arr[++i]; arr[i] = arr[j]; arr[j] = tmp; } } // pivot을 pivot보다 작은 요소들의 바로 오른쪽에 배치 tmp = arr[i + 1]; arr[i + 1] = arr[end]; arr[end] = tmp; return i + 1;}" }, { "title": "[CS] 2의 보수와 컴퓨터의 실수 표현", "url": "/posts/2s-complement-real-number/", "categories": "Computer Science", "tags": "", "date": "2021-03-30 00:00:00 +0900", "snippet": "2의 보수부호 절댓값 방법최상위 비트를 부호 비트로 사용한다. 최상위 비트가 0이면 양수, 1이면 음수이다.예) 0011₂ = 3₁₀ , 1011₂ = -3₁₀이 방법을 사용하면 계산에 문제가 발생한다.예) 0001₂(1₁₀) + 1001₂(-1₁₀) = 1010₂(-2₁₀) (1 + (-1)의 결과로 0이 나와야 하는데 -2가 나오게 된다)1의 보수 방법계산할 이진수보다 1비트가 더 크고 모든 자릿수가 1인 수에서 원래 수를 빼서 구할 수 있다.각 자리수의 0과 1을 서로 뒤바꾼 것과 같다.예) 1101₂ = -2₁₀ , 1000 = -7₁₀덧뻴셈이 가능하다. 단 자리올림이 발생하면 최하위 비트에 1을 더해야 한다.예1) 1101₂(-2₁₀) + 1100₂(-3₁₀) = 1001₂ + 0001₂ = 1010₂(-5₁₀)예2) 0001₂(1₁₀) + 1110₂(-1₁₀) = 1111(-0₁₀)그러나 부호 절댓값 방법과 마찬가지로 0을 표현하는 방법이 2가지이다.2의 보수 방법계산할 이진수보다 1비트가 더 크고 최상위비트만 1인 수에서 원래 수를 빼서 구할 수 있다.또한 1의 보수에서 1을 더한 값과도 같다.예) 1110₂ = -2₁₀ , 1001 = -7₁₀기존 방법들과는 다르게 0을 표현하는 방법이 1가지 뿐이며 자리올림 문제가 해결되었다.양수로 표현할 수 있는 수의 최댓값보다 1만큼 큰 수를 절댓값으로 가지는 음수까지 표현할 수 있다.컴퓨터의 실수 표현컴퓨터에서 실수는 아래와 같이 가수, 밑수, 지수의 3개 부분으로 구성되어있다.\\[m×r^e⠀( m : 가수⠀r : 밑수⠀e : 지수 )\\]지수는 바이어스 된 표현법인데, 바이어스라는 고정된 값을 더해서 구할 수 있다.컴퓨터는 이진법을 사용하므로 밑수는 2₁₀로 고정되어있다.가수를 표현할 때 소수점 아래 0은 모두 생략하며, 첫 번째 1도 생략한다.따라서 정수 부분은 1로 고정시키고 소수점 아래 숫자들만을 가수 부분에 저장한다.이와 같은 지수 형식을 이용한 표현에는 단일 정밀도 형식과 이중 정밀도 형식이 있다.단일 정밀도 형식전체 : 32비트부호비트 : 1비트지수 부분 : 8비트가수 부분 : 23비트바이어스 : 127지수 표현 범위 : -127 ~ 128이중 정밀도 형식전체 : 64비트부호비트 : 1비트지수 부분 : 11비트가수 부분 : 52비트바이어스 : 1023지수 표현 범위 : -1023 ~ 1024실수의 오차어떤 수를 십진 분수로 나타냈을 때 분모에 2 외의 인수가 있다면 그 수는 무한이진소수점수가 된다.그러나 가수 부분 저장 공간은 유한하기 때문에 특정 자릿수에서 반올림이 일어나게 되며, 많은 숫자들은 정확한 값이 아닌 근사치로 저장되기 때문에 오차가 발생한다.예를 들어, 컴퓨터가 0.1 * 0.1을 계산할 때 0.1은 이진수로 바꾸면 무한이진소수점수가 되므로 정확안 값이 아닌 근사치로 연산이 이루어지는데 그 결과는 0.01과 가장 근접한 이진소수점수가 아니기 때문에 아래와 같은 코드를 실행시키면 FALSE라는 값이 출력되는 것을 볼 수 있다.#include &amp;lt;stdio.h&amp;gt;int main(){ double num = 0.1; if (num * num == 0.01) printf(&quot;TRUE&quot;); else printf(&quot;FALSE&quot;); return 0;}FALSE" } ]
